\chapter[Concepts élémentaires]{Concepts élémentaires}
\label{chap:XI}


\lettrine[lhang=0.05]{P}{ouvoir écrire de petits programmes} au terme de sa lecture est l'objectif annoncé de ce chapitre. Les concepts essentiels du langage sont ainsi évoqués, dont les plus importants seront repris de manière plus détaillée par la suite.

Aussi, sont abordées les chaînes de caractères, les notions de séquences et de listes, pour ensuite exposer comment les structures de conditionnelles et de boucles d'itération communes à tout langage de programmation sont exprimées en \textsc{Python}. Un aperçu du concept important de compréhension de liste puis une introduction aux modules sont finalement formulés.

%----------
\section[Chaînes de caractères]{Chaînes de caractères}
\label{sec:XI.1}

Les programmes informatiques d'un langage dit de « haut niveau~» comme \textsc{Python} s'écrivent au moyen de chaînes de caractères afin d'être lisible par un être humain. Il faut donc connaître comment ces chaînes de caractère sont codées par l'ordinateur et comment les manipuler pour rédiger des programmes efficients.

\subsection[Codage, décodage, Unicode]{Codage, décodage, Unicode}
\label{sub:XI.1.1}

Avant de se lancer dans la programmation à proprement parler, les notions d'encodage et de décodage sont fondamentales à comprendre. En particulier, le langage \textsc{Python} supporte l'Unicode en natif. Que cela recouvre-t-il et comment procéder ?

\subsubsection[Encodage et manipulation]{Encodage et manipulation}
\label{subsub:XI.1.1.1}

Considérons pour débuter la suite de lettres suivante : « JEFAISUNMOOCSURPYTHON ». Il faut quelques instants au cerveau pour décrypter sa signification ou, autrement dit décoder l'information en « JE FAIS UN MOOC SUR PYTHON ».

En informatique, les opérations ne se réalisent pas avec des lettres mais en manipulant des flux de bits. La question qui peut alors se poser est de savoir comment passer de flux de bits à la notion de lettre. 

Le principe est le même que précédemment en appliquant une opération de décodage. Cela va consister à découper le flux de bits en une suite de blocs d'une certaine taille qui chacun ont un sens selon une convention donnée au préalable.

Avec le codage ASCII --- \textit{American Standard Code for Information Interchange}\sidenote{Le codage ASCII est la première transcription binaire des caractères alphanumériques. Seul l'alphabet latin sans lettre accentuée est codé pour s'adapter à l'anglais (voir \cref{chap:V} \cref{subsub:V.1.2.2}).} ---, les différents blocs sont d'une taille de 7 bits. Pour s'en faire une idée, prenons un exemple de flux de bits (cf. \cref{fig:XI.1}).

\begin{figure}
\centering
\begin{tikzpicture}
%\draw[step=0.25cm, style=help lines, line width=0.1pt] (-5,-2.0) grid (5,2.0);
%\draw[step=1cm, style=help lines, line width=0.4pt] (-5,-2.0) grid (5,2.0);
\node[xshift=-1.0cm] at (0.0,1.5) {\texttt{11000011101100110100111000111100101}};
\node[xshift=-1.0cm] at (0.0,1.0) {$\underbrace{\texttt{1100001}}$ $\underbrace{\texttt{1101100}}$ 
										$\underbrace{\texttt{1101001}}$ $\underbrace{\texttt{1100011}}$ $\underbrace{\texttt{1100101}}$};
\node[xshift=-1.0cm] at (-2.66,0.5) {\texttt{97}};
\node[xshift=-1.0cm] at (-1.325,0.5) {\texttt{108}};
\node[xshift=-1.0cm] at (0.0,0.5) {\texttt{105}};
\node[xshift=-1.0cm] at (1.325,0.5) {\texttt{99}};
\node[xshift=-1.0cm] at (2.66,0.5) {\texttt{101}};
\node[anchor=west, font=\small, inner sep=0pt] at (2.5,1.5) {Flux de bits};
\node[anchor=west, font=\small, inner sep=0pt] at (2.5,1.0) {Blocs de 7 bits};
\node[anchor=west, font=\small, inner sep=0pt] at (2.5,0.5) {Conversion décimale};
\node[xshift=-1.0cm] at (-2.66,0.0) {\texttt{a}};
\node[xshift=-1.0cm] at (-1.325,0.0) {\texttt{l}};
\node[xshift=-1.0cm] at (0.0,0.0) {\texttt{i}};
\node[xshift=-1.0cm] at (1.325,0.0) {\texttt{c}};
\node[xshift=-1.0cm] at (2.66,0.0) {\texttt{e}};
\node[anchor=west, font=\small, inner sep=0pt] at (2.5,0.0) {Jeu de caractères ASCII};
\node[xshift=-1.0cm] at (-2.66,-0.5) {\textit{\textbf{a}}};
\node[xshift=-1.0cm] at (-1.325,-0.5) {\textit{\textbf{l}}};
\node[xshift=-1.0cm] at (0.0,-0.5) {\textit{\textbf{i}}};
\node[xshift=-1.0cm] at (1.325,-0.5) {\textit{\textbf{c}}};
\node[xshift=-1.0cm] at (2.66,-0.5) {\textit{\textbf{e}}};
\node[anchor=west, font=\small, inner sep=0pt] at (2.5,-0.5) {Police Fira Sans Bold Italic};
\end{tikzpicture}
\caption{\label{fig:XI.1}Codage ASCII (la conversion décimale n'existe pas dans un ordinateur).}
\end{figure}

\begin{marginvideo}
	[\label{vid:XI.1}Codage et décodage des caractères alphanumériques.]%
	\movie[width=\marginparwidth,showcontrols]%
		{\includegraphics[width=\marginparwidth]{./Images/Pictograms/film-strip-dark-electric-blue.png}}%
		{./Videos/Chapter11/vidXI-01-codage-HD.mp4}%
	\launchvideo{./Videos/Chapter11/vidXI-01-codage-HD.mp4}
\end{marginvideo}

Ainsi, lors de la lecture d'un contenu textuel sur Internet ou provenant du disque dur, il s'agit de flux de bits qui sont décodés. De manière inverse, lorsque des données textuelles sont téléversées sur Internet ou enregistrées sur disque dur, elles sont codées en flux de bits selon une convention déterminée.

Toutefois, on peut remarquer que le codage ASCII n'autorise que 128 caractères différents ($2^7 = 128$). C'est largement insuffisant, ne serait-ce que pour les langues d'Europe de l'Ouest comme le français ou l'allemand. C'est pourquoi pendant longtemps, des codages dits « ASCII étendus » sur 8 bits ($2^8 = 256$) ont été utilisés. Cela reste insuffisant pour pouvoir universellement coder tous les caractères existants, notamment pour les langues orientales et asiatiques. 

Pendant longtemps, une multitude de tables de jeux de caractères a coexisté, provoquant des incompatibilités de lecture et de diffusion des données textuelles ; les ordinateurs n'étant pas configurés avec tous les jeux de caractères.

Pour pallier ce problème, le projet Unicode, débuté en 1991, a pour ambition de coder tous les caractères existants. À ce jour, cette opération est réalisée pour plus de 120\,000 d'entre eux. Unicode utilise différents types de codage : UTF-8, UTF-16 et UTF-32. Sans rentrer dans les détails, il faut savoir qu'ils résultent d'un compromis entre compacité du codage et rapidité de décodage. En pratique, le codage UTF-8 est le plus usité qui possède la propriété d'être entièrement compatible avec l'ASCII standard.

\begin{linewidthnote}
\textsc{Python} a l'avantage d'être lui aussi compatible avec Unicode, au prix d'un contrôle strict de son utilisation. La règle est simple :  sans mention explicite contraire provenant d'anciens documents toujours actifs, il faut impérativement indiquer au sein des programmes l'emploi du codage UTF-8. 
\end{linewidthnote}


\overparagraph{Caractères accentués}

La question des caractères accentués dépasse très largement le cadre de \textsc{Python} et s'avère parfois relativement scabreuse. Qu'est-il possible de faire et quelles sont les prérogatives ?

Avec Unicode, le modèle qui établit la correspondance entre un caractère et un octet est cassé. Aussi en \textsc{Python\,3}, lorsqu'il s'agit de manipuler des données provenant de diverses sources de données, les alternatives sont les suivantes :
\begin{itemize}
	\item le type \texttt{byte} est approprié pour charger en mémoire les données binaires brutes, sous forme d'octets ;
	\item le type \texttt{str} est approprié pour représenter une chaîne de caractères qui, à nouveau, \emph{ne sont pas forcément des octets} ;
\end{itemize}
Le passage de l'un à l'autre de ces types se réalise par des opérations d'encodage et décodage. Pour \emph{toutes} les opérations de codage et décodage, il est nécessaire de connaître l'encodage utilisé.

On peut appeler les méthodes \texttt{encode} et \texttt{decode} sans préciser l'encodage (dans ce cas \textsc{Python} choisit l'encodage par défaut du système hôte). Cela dit, il est de loin préférable d'être explicite et de sélectionner son encodage. En cas de doute, il est recommandé de spécifier explicitement \texttt{utf-8} --- au détriment d'encodages anciens comme \texttt{cp1252} (Windows) et \texttt{iso8859-*} ---, que de laisser le choix au système.

\textsc{Python\,3} supporte l'Unicode par défaut. On peut donc désormais utiliser sans aucun risque des accents ou des cédilles dans les chaînes de caractères. Il faut cependant être vigilant à deux choses :
\begin{enumerate}
	\item les ordinateurs n'ont pas forcément les polices de caractères nécessaires pour afficher tous les caractères existants ;
	\item bien que les caractères Unicode soit possibles pour les noms de variables, il est recommandé dans la mesure du possible d'écrire les codes en anglais, comme c'est le cas de la quasi-totalité du code des bibliothèques. Ceci est particulièrement important pour les noms de lignes et de colonnes dans un jeu de données, afin de faciliter les transferts entre logiciels ; la majorité des logiciels n'acceptant pas les accents et cédilles dans les noms de variables.
\end{enumerate}
Ainsi, il faut bien distinguer les chaînes de caractères qui doivent par nature être adaptées au langage des utilisateurs du programme, et le code source qui, pour sa part, est destiné aux programmeurs et doit donc éviter d'employer autre chose que de l'anglais.

\overparagraph{Où et comment utiliser des accents ?}

\paragraph{Nom de variable et identificateur} S'il n'était pas possible en \textsc{Python\,2} d'utiliser un caractère accentué dans un nom de variable --- ou pour un identificateur au sens large ---, c'est à présent toléré avec \textsc{Python\,3}.

\begin{nbjupyterin}[before skip=4pt,after skip=6pt]{1}
nb_élèves = 12  # pas recommandé, mais autorisé par le langage
\end{nbjupyterin}

On peut même utiliser des symboles, comme par exemple

\begin{nbjupyterin}[before skip=4pt,after skip=1pt]{2}
from math import cos, pi as §Π§
§θ§ = §Π§ / 4
cos(§θ§)
\end{nbjupyterin}
\begin{nbjupyterout}[after skip=4pt]{2}
0.7071067811865476
\end{nbjupyterout}

\emph{Il est fortement recommandé de ne pas employer cette possibilité sans être extrêmement familier avec les caractères Unicode.}

\caution[t]<firstcolor>{\url{https://docs.python.org/3/reference/lexical\_analysis.html\#identifiers}}{Documentation officielle}
Enfin, pour être exhaustif, il faut savoir que seule une partie des caractères Unicode est autorisée dans ce cadre,. C'est heureux parce que certains caractères, comme par exemple l'\href{http://www.fileformat.info/info/unicode/char/a0/index.htm}{espace non-sécable}, pourraient, s'ils étaient autorisés, être la cause de milliers d'heures de \textit{debugging} à frustration garantie !

\paragraph{Chaînes de caractères} On peut naturellement mettre des accents dans les chaînes de caractères. Cela dit, les données manipulées par un programme proviennent pour l'essentiel de sources externes, comme une base de données ou un formulaire Web et non, le plus souvent, directement du code source. Les chaînes de caractères présentes dans du vrai code sont bien souvent limitées à des messages de \textit{logging} et en anglais, donc sans accent.

Lorsqu'un programme doit interagir avec les utilisateurs et « parler~» leur langue, c'est une bonne pratique de créer un fichier spécifique, que l'on appelle \emph{fichier de ressources}, qui contient toutes les chaînes de caractères spécifiques à une langue. Ainsi, la traduction du programme consistera à simplement modifier ce fichier de ressources.

\paragraph{Commentaires} Bien entendu, on peut mettre dans les commentaires n'importe quel caractère Unicode et notamment des caractères accentués si on choisit malgré tout d'écrire le code en français.

\overparagraph{Encodage}

La mémoire --- ou le disque --- d'un ordinateur ne permet que de stocker des représentations binaires. Il n'y a donc pas de façon « naturelle » de représenter un caractère comme `A', un guillemet ou un point-virgule.

On utilise pour cela un encodage, par exemple le code US-ASCII stipule, pour faire simple, qu'un `A' est représenté par l'octet 65 qui s'écrit en binaire \texttt{01000001}. Il se trouve qu'il existe plusieurs encodages, bien sûr incompatibles, selon les systèmes et les langues...

Le point important est que pour pouvoir ouvrir un fichier « proprement », il faut non seulement disposer du \emph{contenu} du fichier, mais aussi connaître l'\emph{encodage} qui a été employé pour l'écrire.

\paragraph{Précautions d'encodage des codes sources} L'encodage ne concerne pas simplement les objets chaîne de caractères, mais également l'ensemble du code source. \textsc{Python\,3} considère que le code source utilise par défaut l'encodage UTF-8. Il est conseillé de conserver cet encodage ; c'est celui qui offre le plus de flexibilité.

Il est malgré tout possible de changer l'encodage du code source en faisant figurer \emph{en première ou deuxième ligne} des fichiers, une déclaration comme :

\begin{nbjupyterin}[before skip=4pt,after skip=6pt]{}
# -*- coding: <nom_de_l_encodage> -*-
\end{nbjupyterin}

\noindent ou plus simplement, comme ceci :

\begin{nbjupyterin}[before skip=4pt,after skip=6pt]{}
# coding: <nom_de_l_encodage>
\end{nbjupyterin}

Notons que la première option est également interprétée par l'éditeur de texte \texttt{Emacs} pour utiliser le même encodage. En dehors de l'utilisation d'\texttt{Emacs}, la deuxième option, plus simple et donc plus « pythonique », est à préférer.

Le nom UTF-8 fait référence à Unicode --- ou pour être précis, à l'encodage le plus répandu parmi ceux qui sont définis dans la norme Unicode (cf. infra). Sur certains systèmes plus anciens on peut être amenés à utiliser un autre encodage. Pour déterminer la valeur à employer, on peut saisir dans un interpréteur interactif :

\begin{idleconsole}
	\begin{pyconsole}
		# À exécuter sur la machine hôte
		import sys # (ici Linux Ubuntu MATE 20.04 LTS)
		print(sys.getdefaultencoding())
	\end{pyconsole}
\end{idleconsole}

Par exemple avec d'anciennes versions de \textsc{Windows} (en principe de plus en plus rares) on peut être amenés à écrire :

\begin{nbjupyterin}[before skip=4pt,after skip=6pt]{}
# coding: cp1252
\end{nbjupyterin}

La syntaxe de la ligne \texttt{coding} est précisée dans la \href{https://docs.python.org/3/reference/lexical_analysis.html\#encoding-declarations}{documentation officielle} et dans le \href{https://www.python.org/dev/peps/pep-0263/}{PEP 263}.

\paragraph{Grand malentendu} Si un fichier contenant du français est encodé avec, disons, ISO/IEC 8859-15 --- à savoir Latin-9; on constate que dans la table, un caractère « \texttt{€} » se matérialise par un octet `\texttt{0xA4}', soit \texttt{164}. Imaginons maintenant que l'on essaye d'ouvrir ce même fichier depuis un vieil ordinateur \textsc{Windows} configuré pour le français. Si on ne lui donne aucune indication sur l'encodage, le programme qui va lire ce fichier va utiliser l'encodage par défaut du système, c'est-à-dire CP1252. L'octet `\texttt{0xA4}' correspond au caractère « \texttt{¤} » à la place de « \texttt{€} ».

Contrairement à ce qu'on pourrait espérer, ce type de problème ne se règle pas en ajoutant une balise \texttt{\# coding:} \texttt{<nom\_de\_l\_encodage>}, qui n'agit que sur l'encodage utilisé pour lire le fichier source en question (celui qui contient la balise).
Pour pallier correctement ce type de problème, il faut préciser explicitement l'encodage à utiliser pour décoder le fichier, donc avoir un moyen fiable de déterminer cet encodage ; ce qui n'est pas toujours aisé d'ailleurs. Cela signifie que pour être totalement propre, il faut pouvoir préciser explicitement le paramètre \texttt{encoding} à l'appel de toutes les méthodes qui sont susceptibles d'en avoir besoin.

\paragraph{Pourquoi cela fonctionne en local ?} Lorsque le producteur --- programme qui écrit le fichier --- et le consommateur --- programme qui le lit --- tournent sur le même ordinateur, tout fonctionne bien parce que les deux programmes se rapportent à l'encodage par défaut.

Il y a toutefois une limite, si on utilise un \textsc{Linux} configuré\sidenote{Par exemple, en version serveur ou embarqué.} de manière minimale, il se peut que l'encodage par défaut soit l'US-ASCII qui ne « connaît » pas un simple « \texttt{é} », ni \textit{a fortiori} « \texttt{€} ». Pour écrire du français, il faut donc au minimum que l'encodage par défaut de l'ordinateur contienne les caractères accentués, comme par exemple : ISO 8859-1 (Latin-1), ISO 8859-15 (Latin-9), CP1252 et UTF-8, ce dernier étant à clairement préférer lorsque c'est possible.

\paragraph{Histoire des encodages} Jusque dans les années 1980, les ordinateurs ne « parlaient » pour l'essentiel que l'anglais. La première vague de standardisation avait créé l'encodage dit \href{http://www.asciitable.com/}{ASCII}, ou encore \href{https://en.wikipedia.org/wiki/ASCII}{US-ASCII} (voir aussi \cref{chap:V} \qnameref{chap:V} \cref{subsub:V.1.2.2}).

Le code US-ASCII s'étend sur 128 valeurs, soit 7 bits, mais est le plus souvent implémenté sur un octet pour préserver l'alignement, le dernier bit pouvant être utilisé par exemple pour ajouter un code correcteur d'erreur --- ce qui à l'époque des modems n'était pas superflu. Bref, la pratique courante était alors de manipuler une chaîne de caractères comme un tableau d'octets.

Dans les années 1990, pour satisfaire les besoins des pays européens, ont été définis plusieurs encodages alternatifs, connus sous le nom de ISO/IEC 8859-*, nommés aussi Latin-*. Idéalement, on aurait pu et certainement dû définir un seul encodage pour représenter tous les nouveaux caractères, mais entre toutes les langues européennes, le nombre de caractères à ajouter était substantiel ; cet encodage unifié aurait largement dépassé 256 caractères différents, il n'aurait donc pas été possible de tout faire tenir sur un octet.

On a préféré préserver la « bonne propriété » du modèle un caractère correspond à un octet, ceci afin de conserver le code existant qui aurait sinon dû être retouché ou réécrit. Dès lors, il n'y avait pas d'autre choix que de définir plusieurs encodages distincts. Par exemple, pour le français on a utilisé ISO/IEC 8859-1 (Latin-1), pour le russe ISO/IEC 5589-5 (Latin/Cyrillic).
À ce stade, le ver était dans le fruit. Depuis cette époque, pour ouvrir un fichier il faut connaître son encodage.

Lorsque l'on a ensuite cherché à manipuler aussi les langues asiatiques, il a de toute façon fallu définir de nouveaux encodages beaucoup plus larges. C'est ce qui a été fait par le standard Unicode qui définit trois nouveaux encodages :
\begin{itemize}
	\item UTF-8 : un encodage à taille variable, à base d'octets, qui maximise la compatibilité avec US-ASCII ;
	\item UTF-16 : un encodage à taille variable, à base de mots de 16 bits ;
	\item UTF-32 : un encodage à taille fixe, à base de mots de 32 bits.
\end{itemize}

Ces standards couvrent le même jeu de caractères (113 021 tout de même dans la dernière version). Parmi ceux-ci le plus utilisé est certainement UTF-8. Un texte ne contenant que des caractères du code US-ASCII initial peut être lu avec l'encodage UTF-8.

Pour être enfin tout à fait exhaustif, si on sait qu'un fichier est au format Unicode, on peut déterminer quel est l'encodage qu'il utilise en se fondant sur les quatre premiers octets du document. Ainsi dans ce cas particulier (lorsqu'on est sûr qu'un document utilise un des trois encodages Unicode) il n'est plus nécessaire de connaître son encodage de manière « externe ».

\subsubsection[Outils et formatage]{Outils et formatage}
\label{subsub:XI.1.1.2}

Cette section s'attache au maniement des chaînes de caractères et à leur encodage. On peut tout de suite noter que \textsc{Python\,3} gère désormais nativement l'Unicode, ce qui n'était pas le cas auparavant ; cela offre un très bon argument pour passer à cette nouvelle version.

\overparagraph{Objets chaînes de caractères}

\begin{marginvideo}
	[\label{vid:XI.2}Chaînes de caractères I.]%
	\movie[width=\marginparwidth,showcontrols]%
		{\includegraphics[width=\marginparwidth]{./Images/Pictograms/film-strip-dark-electric-blue.png}}%
		{./Videos/Chapter11/vidXI-02a-strings-HD.mp4}%
	\launchvideo{./Videos/Chapter11/vidXI-02a-strings-HD.mp4}
\begin{minipage}{\linewidth}
\vspace*{2pt}
\footnotesize\textit{Erratum} : À 5:05, les \texttt{f-string} sont introduites depuis \textsc{Python} 3.6 et non 3.5.
\end{minipage}
\end{marginvideo}
\marginpar{\footnotesize\noindent \textsc{Bloc-note \cref{vid:XI.2}} (copier-coller)\\
\texttt{'spam'}\\
\texttt{"spam"}\\
\texttt{s = 'spam'}\\
\texttt{str?}\\
\texttt{dir(str)}\\
\texttt{'un mooc sur python'.title()}\\
\texttt{s = "le chocolat c'est bon"}\\
\texttt{s.replace('chocolat', 'spam')}\\
\texttt{s}\\
\texttt{'123'.isdecimal()}\\
\texttt{n = 'sonia'}\\
\texttt{age = 30}\\
\texttt{"\{\} \{\}".format(n, age)}\\
\texttt{"\{\} a \{\} ans".format(n, age)}\\
\texttt{f"\{n\} a \{age\} ans"}}

Créer une chaîne de caractère est très simple, il suffit de l'entourer d'apostrophes ou bien de guillemets si la chaîne contient elle-même des apostrophes. Pour la manipuler, on l'affecte à une variable.

\begin{idleconsole}
	\begin{pyconsole}
		'spam'
		"spam"
		s = 'spam'
	\end{pyconsole}
\end{idleconsole}

Les chaînes de caractères sont des \emph{objets immuables}, c'est-à-dire qu'une fois créés ils ne sont plus modifiables. Les chaînes de caractères comportent de nombreuses méthodes. Ces objets étant immuables, chaque fonction va retourner un nouvel objet chaîne de caractères. 

Comment connaître toutes ces méthodes applicables aux chaînes de caractères ? \textsc{Python} est un langage auto-documenté, c'est-à-dire que l'aide peut être interrogée depuis l'interpréteur, soit par l'ajout d'un point d'interrogation à la commande recherchée (depuis \textsc{IPython} ou un \textit{notebook}) comme par exemple \texttt{str?} pour les objets chaînes de caractères, soit en saisissant « \texttt{help} » devant la commande (depuis IDLE).

Pour par exemple lister toutes les méthodes associées aux chaînes de caractères, il faut utiliser la fonction \textit{built-in} « \texttt{dir} » : \texttt{dir(str)}.
%\begin{idleconsole}[after skip=6pt]
%	\begin{pyconsole}
%		dir(str)
%	\end{pyconsole}
%\end{idleconsole}
On constate que certaines méthodes débutent et se finissent par des doubles \textit{underscores}. Elles seront détaillée ultérieure car il s'agit de propriétés avancées liées aux méthodes spéciales.

Le nom des méthodes est souvent explicite. Prenons pour exemple les méthodes « \texttt{title} » et « \texttt{replace} ». La première met en capitale la première lettre de chaque mot de la chaîne de caractères, la seconde remplace un mot donné de la chaîne de caractères.

\begin{idleconsole}
	\begin{pyconsole}
		'un mooc sur python'.title()
		s = "le chocolat c'est bon"
		s.replace('chocolat', 'spam')
	\end{pyconsole}
\end{idleconsole}

On note au passage que si l'on veut introduire des apostrophes dans une chaîne de caractères, il suffit de la mettre entre guillemets ; cela évite l'emploi du caractère d'échappement \textit{backslash} « \texttt{\textbackslash} ».

D'autres méthodes permettent de conduire des tests et d'établir des comparaisons. Supposons par exemple avoir la chaîne de caractère de l'entier \texttt{'123'}. Avant de la convertir, on peut s'assurer que cela représente bien un nombre décimal. Cela se réalise avec la méthode \texttt{isdecimal} qui retourne ici \texttt{True}. Chacun est invité à consulter l'intégralité des méthodes sur les chaîne de caractère, car elles sont très puissantes et à même de très souvent répondre aux besoins.

\begin{idleconsole}
	\begin{pyconsole}
		'123'.isdecimal()
	\end{pyconsole}
\end{idleconsole}

Le formatage d'une chaîne de caractères se réalise en \textsc{Python} avec l'instruction « \texttt{format()} » ou, de manière expressive et à utiliser systématiquement, à l'aide des \textit{fstrings} depuis \textsc{Python\,3.5} (cf. infra). 

\begin{idleconsole}
	\begin{pyconsole}
		n = 'sonia'
		age = 30
		"{} {}".format(n, age)
		"{} a {} ans".format(n, age)
		f"{n} a {age} ans"
	\end{pyconsole}
\end{idleconsole}

\vspace{.25\baselineskip}

\overparagraph{Support Unicode}

\begin{marginvideo}
	[\label{vid:XI.3}Chaînes de caractères II.]%
	\movie[width=\marginparwidth,showcontrols]%
		{\includegraphics[width=\marginparwidth]{./Images/Pictograms/film-strip-dark-electric-blue.png}}%
		{./Videos/Chapter11/vidXI-02b-strings-HD.mp4}%
	\launchvideo{./Videos/Chapter11/vidXI-02b-strings-HD.mp4}
\end{marginvideo}
\marginpar{\footnotesize\noindent \textsc{Bloc-note \cref{vid:XI.3}} (copier-coller)\\
\texttt{"noël, été"}\\
\texttt{"\textbackslash{u03a6}"}\\
\texttt{"\textbackslash{u0556}"}\\
\texttt{s = "un noël en été"}\\
\texttt{print(s)}\\
\texttt{s.encode('utf8')}\\
\texttt{en = s.encode('utf8')}\\
\texttt{en}\\
\texttt{en.decode('utf8')}\\
\texttt{s.encode('latin1')}}

Il est permis de saisir directement les caractères Unicode dans un interpréteur, mais il aussi possible d'entrer le code du caractère comme par exemple « \texttt{\textbackslash{u}03a6} » pour obtenir la lettre grecque Phi « {\fontspec{DejaVu Sans}\symbol{"03A6}} ».

\begin{idleconsole}
	\begin{pyconsole}
		"noël, été"
		"\u03a6"
		"\u0556"
	\end{pyconsole}
\end{idleconsole}

Par ailleurs, en saisissant « \texttt{\textbackslash{u}0556} », on obtient aucun affichage alors que le caractère attendu correspond à la trente-huitième lettre de l'alphabet arménien, Feh. Cela provient simplement de la police de caractères de l'interpréteur qui ne dispose pas de ce symbole. Il suffit d'aller changer la fonte dans les options de l'interpréteur. Par exemple, on a bien la lettre Feh « {\fontspec{DejaVu Sans}\symbol{"0556}} » avec la police DejaVu Sans.

\begin{idleconsole}
	\begin{pyconsole}
		s = "un noël en été"
		print(s)
		s.encode('utf8')
		en = s.encode('utf8')
		en
		en.decode('utf8')
		s.encode('latin1')
	\end{pyconsole}
\end{idleconsole}

Les opérations de codage et décodages de chaînes de caractères sont simples en \textsc{Python}. Dès qu'on utilise des caractères, on fait appel au type « \texttt{str} ». Dès que l'on manipule des flux de bits, on a recours au type « \texttt{bytes} ». \textsc{Python} permet facilement de passer de l'un à l'autre à l'aide des méthodes \texttt{encode} et \texttt{decode} (voir supra encart IDLE).

Lorsqu'on encode une chaîne de caractères, \textsc{Python} retourne une ligne débutant par  « \texttt{b} » pour bytes, puis une suite de glyphes qui correspondent à des octets. En effet, \textsc{Python} offre un affichage sous forme de lettre ou forme chiffre lorsque l'octet correspond au code d'un caractère ASCII. Il ne s'agit que d'une facilité et le codage est bien réalisé en octet. Inversement, on revient à une chaîne de caractère par la fonction \texttt{decode}. On peut noter que, bien qu'il soit très fortement indiqué d'utiliser UTF-8, d'autres encodages, tel que Latin-1 sont possibles.

\overparagraph{Manipulation des chaînes de caractères}

Même après des années de pratique, il est toujours difficile de se souvenir de toutes les méthodes sur les chaînes de caractères. Aussi, le recours à la documentation\sidenote{Pour des renseignements plus exhaustifs, consulter la \href{https://docs.python.org/3/library/stdtypes.html\#string-methods}{documentation en ligne} concernant les chaînes de caractères.} embarquée est efficace : \texttt{help(str)}.

Il est donc illusoire de les citer toutes et on se restreint ici aux plus employées. De plus, elles sont abordées de manière simple et, bien souvent, il est possible de passer en argument des options permettant de ne travailler que sur une sous-chaîne ou sur la première ou la dernière occurrence d'une sous-chaîne. Renvoi est fait à la documentation pour obtenir toutes les précisions voulues.

\paragraph{Découpage--Assemblage : {\normalfont\texttt{split}} et {\normalfont\texttt{join}}}
Les méthodes \texttt{split} et \texttt{join} permettent respectivement de découper une chaîne selon un séparateur pour obtenir une liste et, à l'inverse, de reconstruire une chaîne à partir d'une liste.

\begin{idleconsole}
	\begin{pyconsole}
		'abc=:=def=:=ghi=:=jkl'.split('=:=')
		"=:=".join(['abc', 'def', 'ghi', 'jkl'])
	\end{pyconsole}
\end{idleconsole}

Attention toutefois si le séparateur est un terminateur, la liste résultat contient alors une dernière chaîne vide. En pratique, on utilise la méthode \texttt{strip} avant la méthode \texttt{split} pour éviter ce problème.

\begin{idleconsole}
	\begin{pyconsole}
		'abc;def;ghi;jkl;'.split(';')
		";".join(['abc', 'def', 'ghi', 'jkl', ''])
	\end{pyconsole}
\end{idleconsole}

\vspace{1pt}

\paragraph{Remplacement : {\normalfont\texttt{replace}}}
La méthode \texttt{replace} est très pratique pour remplacer une sous-chaîne par une autre, avec une limite éventuelle sur le nombre de substitutions à effectuer.

\begin{idleconsole}
	\begin{pyconsole}
		"abcdefabcdefabcdef".replace("abc", "zoo")
		"abcdefabcdefabcdef".replace("abc", "zoo", 2)
	\end{pyconsole}
\end{idleconsole}

Plusieurs appels à \texttt{replace} peuvent être chaînés comme suit.

\begin{idleconsole}
	\begin{pyconsole}
		"le [x] qui [y]".replace("[x]", "chat").replace("[y]", "miaule")
	\end{pyconsole}
\end{idleconsole}

\vspace{1pt}

\paragraph{Nettoyage : {\normalfont\texttt{strip}}}
On pourrait par exemple utiliser \texttt{replace} pour enlever les espaces dans une chaîne, ce qui peut être utile pour « nettoyer » la chaîne de caractères.

\begin{idleconsole}
	\begin{pyconsole}
		" abc:def:ghi ".replace(" ", "")
	\end{pyconsole}
\end{idleconsole}

Toutefois, bien souvent, on préfère faire appel à la méthode \texttt{strip} qui ne s'occupe que du début et de la fin de la chaîne, tout en gérant également les tabulations et autres retour à la ligne.

\begin{idleconsole}
	\begin{pyconsole}
		" \tune chaîne avec des trucs qui dépassent \n".strip()
	\end{pyconsole}
\end{idleconsole}

On peut appliquer la méthode \texttt{strip} avant \texttt{split} pour éviter le problème du dernier élément vide (cf. supra).

\begin{idleconsole}
	\begin{pyconsole}
		'abc;def;ghi;jkl;'.strip(';').split(';')
	\end{pyconsole}
\end{idleconsole}

\paragraph{Rechercher une sous-chaîne}
Plusieurs outils permettent de chercher une sous-chaîne. Il existe \texttt{find} qui renvoie le plus petit index où on trouve la sous-chaîne.

\begin{idleconsole}
	\begin{pyconsole}
		"abcdefcdefghefghijk".find("def") # Indice première occurrence
		"abcdefcdefghefghijk".find("zoo") # ou -1 si chaîne absente
\end{pyconsole}
\end{idleconsole}

La méthode \texttt{rfind} fonctionne comme \texttt{find} mais en partant de la fin de la chaîne. À noter que le résultat correspond toujours au début de la chaîne --- en \textsc{Python} les indices commencent à zéro donc la notation \texttt{ma\_chaine[n]} permet d’accéder à la position \texttt{n+1} dans la chaîne.

\begin{idleconsole}
	\begin{pyconsole}
		"abcdefcdefghefghijk".rfind("fgh") # En partant de la fin
		"abcdefcdefghefghijk"[13]
\end{pyconsole}
\end{idleconsole}

La méthode \texttt{index} se comporte comme \texttt{find}, mais en cas d'absence elle lève une exception\sidenote{Ce concept est abordé plus tard.} plutôt que de renvoyer \texttt{-1}.

\begin{idleconsole}[after skip=2pt]
\begin{pyconsole}
"abcdefcdefghefghijk".index("def")
\end{pyconsole}
\end{idleconsole}

\begin{idleconsole}
\begin{pyconsole}
try:
	"abcdefcdefghefghijk".index("zoo")
except Exception as e:
	print("OOPS", type(e), e)

\end{pyconsole}
\end{idleconsole}

Mais le plus simple pour chercher si une sous-chaîne est dans une autre chaîne est d'utiliser l'instruction\sidenote{Cette instruction est présentée avec les séquences.} \texttt{in}.

\begin{idleconsole}
\begin{pyconsole}
"def" in "abcdefcdefghefghijk"

\end{pyconsole}
\end{idleconsole}

La méthode \texttt{count} compte le nombre d'occurrences d'une sous-chaîne. On peut également mentionner les méthodes de commodité \texttt{startswith} et \texttt{endswith}.

\begin{idleconsole}
	\begin{pyconsole}
		"abcdefcdefghefghijk".count("ef")
		"abcdefcdefghefghijk".startswith("abcd")
		"abcdefcdefghefghijk".endswith("ghijk")
\end{pyconsole}
\end{idleconsole}

On note ici la supériorité en terme d'expressivité des méthodes «~pythoniques » \texttt{startswith} et \texttt{endswith} en remarquant que :\\[2pt]
%\begin{itemize}
%\item \texttt{chaine.startswith(sous\_chaine)} $\Longleftrightarrow$\\ \texttt{chaine.find(sous\_chaine) == 0} ;
%\item \texttt{chaine.endswith(sous\_chaine)} $\Longleftrightarrow$\\ \texttt{chaine.rfind(sous\_chaine) == (len(chaine) - len(sous\_chaine))}.
%\end{itemize}
\texttt{chaine.startswith(sous\_chaine)} $\Leftrightarrow$ \texttt{chaine.find(sous\_chaine) == 0}\\[2pt]
\texttt{chaine.endswith(sous\_chaine)} $\Leftrightarrow$\\ \texttt{chaine.rfind(sous\_chaine) == (len(chaine) - len(sous\_chaine))}

\paragraph{Changement de casse}
Pour conclure sur la présentation des méthodes applicables aux chaînes de caractères, sont exposées celles concernant des changements de casse qui parlent d'elles-mêmes.

\begin{idleconsole}
	\begin{pyconsole}
		"monty PYTHON".upper()
		"monty PYTHON".lower()
		"monty PYTHON".swapcase()
		"monty PYTHON".capitalize()
		"monty PYTHON".title()
\end{pyconsole}
\end{idleconsole}

\vspace{1pt}

\overparagraph{Formatage des chaînes de caractères}

On désigne par formatage les outils qui permettent d'obtenir une présentation fine des résultats, que ce soit pour améliorer la lisibilité lorsqu'on s'adresse à des humains ou pour respecter la syntaxe d'une fonctionnalité à laquelle on peut vouloir passer les données pour un traitement ultérieur.

\paragraph{Fonction {\normalfont\texttt{print}}}
Jusqu'à présent la fonction \texttt{print} a presque toujours été appelé pour afficher les résultats. Comme on l'a vu, celle-ci réalise un formatage sommaire : elle insère un espace entre les valeurs qui lui sont passées.

\begin{idleconsole}
	\begin{pyconsole}
		print(1, 'a', 12 + 4j)
\end{pyconsole}
\end{idleconsole}

La seule subtilité notable concernant \texttt{print} est que, par défaut, elle ajoute un saut de ligne à la fin. Pour éviter ce comportement, on peut passer à la fonction un argument \texttt{end}, inséré au lieu du saut de ligne.

\begin{idleconsole}
\begin{pyconsole}
print("une", "seule", "ligne") # Première ligne
def affiche(): # Seconde ligne en deux appels
	print("une", "autre", end=' ') 
	print("ligne")

affiche()
\end{pyconsole}
\end{idleconsole}

Il faut aussi remarquer que \texttt{print} est capable d'imprimer n'importe quel objet. Cela a a déjà été le cas avec des listes et des tuples, mais cela peut se réaliser avec des modules.

\begin{idleconsole}
	\begin{pyconsole}
		import math
		print('le module math est', math) # Impression d'un module
\end{pyconsole}
\end{idleconsole}

En anticipant un peu sur la suite, voici comment \texttt{print} présente les instances\sidenote{Point d'inquiétude, ces notions sont appréhendées dans un chapitre ultérieur.} de classe.

\begin{idleconsole}
\begin{pyconsole}
class Personne: # Définition de la classe Personne
	pass

personne = Personne() # Création d'une instance
print(personne) # Affichage d'une instance de classe
\end{pyconsole}
\end{idleconsole}

On atteint assez vite les limites de la fonction \texttt{print} :
\begin{itemize}
\item d'une part, on peut vouloir formater une chaîne de caractères sans nécessairement l'imprimer ou bien en tout au moins pas immédiatement ;
\item d'autre part, les espaces ajoutées peuvent être plus néfastes que vraiment profitables ;
\item enfin, on peut aussi avoir besoin de préciser un nombre de chif\-fres significatifs ou de choisir comment présenter une date.
\end{itemize}

C'est pourquoi il est plus courant de formater les chaînes --- c'est-à-dire de calculer des chaînes en mémoire ---, sans nécessairement les imprimer de suite, d'où la présentation des \texttt{f-strings}.

\paragraph{Concept de \textit{f-string}}
Depuis la version 3.6 de \textsc{Python}, on peut utiliser les \textit{f-strings}. C'est le mécanisme de formatage\sidenote{Bien que désormais obsolètes, il est recommandé de lire les sections consacrées à la méthode \texttt{format} et à l'opérateur \texttt{\%} (cf. infra), car encore massivement présents dans les codes existants.} le plus simple et le plus agréable à employer.

\begin{idleconsole}
	\begin{pyconsole}
		prenom, nom, age = 'Jean', 'Dupont', 35 # Quelques variables
		f"{prenom} {nom} a {age} ans" # Un premier f-string
	\end{pyconsole}
\end{idleconsole}

On remarque d'abord que la chaîne commence par « \texttt{f"} », c'est bien sûr pour cela qu'on l'appelle un \textit{f-string}.
On peut bien entendu ajouter le « \texttt{f} » devant toutes les formes du type \textit{string}, qu'ils commencent par « \texttt{'} », « \texttt{"} », « \texttt{'''} » ou encore « \texttt{"""} ».

Ensuite, on note que les zones délimitées entre accolades \texttt{\{ \}} sont remplacées par les valeurs assignées aux variables. La logique d'un \textit{f-string}, c'est tout simplement de considérer l'intérieur d'une expression entre accolades comme du code \textsc{Python}, de l'évaluer et d'en utiliser le résultat. Cela signifie qu'on peut conduire des calculs dans les expressions entre accolades et faire appel à des fonctions.

\begin{idleconsole}
	\begin{pyconsole}
		f"Dans 10 ans {prenom} aura {age + 10} ans" # Calcul
		notes = [12, 15, 19]
		f"Nous avons pour l'instant {len(notes)} notes" # Appel
	\end{pyconsole}
\end{idleconsole}

Les \textit{f-strings} fournissent ainsi une méthode très simple et expressive pour formater des données dans des chaînes de caractère. Pour être bien clair : un \textit{f-string} \emph{ne réalise pas d'impression}, il faut donc le passer à \texttt{print} si l'impression est souhaitée. Reste à étudier comment chaque expression entre accolades est formatée, par exemple comment choisir le nombre de chiffres significatifs sur un flottant.

\paragraph{Formatage des expressions au sein des \textit{f-strings}}
Il arrive qu'on ait besoin de spécifier plus finement la façon dont une valeur doit être affichée ; cela se fait en précisant un format à l'intérieur des expressions entre accolades.

\begin{idleconsole}
	\begin{pyconsole}
		from math import pi
		f"2xPi avec seulement 2 chiffres après la virgule {2*pi:.2f}"
	\end{pyconsole}
\end{idleconsole}

Dans les accolades de l'exemple ci-dessus, on peut mettre avant les deux points n'importe quelle expression --- ne comportant bien entendu pas de deux points ---, opération arithmétique, appel de fonction, etc. Autrement dit, tout ce qui constitue l'expression à évaluer. Après les deux points, la place est réservée pour préciser un format d'affichage --- ici, un nombre flottant avec deux chiffres significatifs après la virgule. 

Pour forcer un petit entier à s'afficher sur quatre caractères, avec des zéro ajoutés au début si nécessaire, on peut saisir ce qui suit.

\begin{idleconsole}
	\begin{pyconsole}
		x = 15
		f"{x:04d}"
	\end{pyconsole}
\end{idleconsole}

On fait appel ici au format \texttt{d} (toutes ces lettres \texttt{d}, \texttt{f}, \texttt{g} viennent des formats ancestraux de la \texttt{libc} des systèmes \textsc{Unix} comme \texttt{printf}). Avec \texttt{04d} on précise qu'on veut une sortie sur 4 caractères et qu'il faut remplir à gauche si nécessaire avec des $0$.\\[1.5pt]
\indent Dans certains cas, on a besoin d'afficher des données en colonnes de largeur fixe, on utilise pour cela les formats « \texttt{<} », « \texttt{\textasciicircum} » et « \texttt{>} » pour afficher à gauche, au centre ou à droite d'une zone de largeur fixe.

\begin{idleconsole}
\begin{pyconsole}
comptes = [ # Données à afficher
 ('Apollin', 'Dupont', 127),
 ('Myrtille', 'Lamartine', 25432),
 ('Prune', 'Soc', 827465),
]
for prenom, nom, solde in comptes:
	print(f"{prenom:<10} -- {nom:^12} -- {solde:>8} €")

\end{pyconsole}
\end{idleconsole}

\vspace{-0.5pt}

\paragraph{Méthode {\normalfont\texttt{format}}}
Avant l'introduction des \textit{f-strings}, la technique recommandée pour faire du formatage était d'avoir recours à la méthode \texttt{format} qui est définie sur les objets \texttt{str}.

\begin{idleconsole}
	\begin{pyconsole}
		prenom, nom, age = 'Jean', 'Dupont', 35
		"{} {} a {} ans".format(prenom, nom, age)
	\end{pyconsole}
\end{idleconsole}

Dans cet exemple le plus simple, les données sont affichées en lieu et place des accolades, dans l'ordre où elles sont fournies.
Cela convient bien lorsqu'on a peu de données. %\\[1.5pt]
Si par la suite on veut changer l'ordre par exemple des \texttt{nom} et \texttt{prénom}, on peut bien sûr échanger l'ordre des arguments passés à \texttt{format} ou encore utiliser la \emph{liaison par position}.

\begin{idleconsole}
	\begin{pyconsole}
		"{1} {0} a {2} ans".format(prenom, nom, age)
	\end{pyconsole}
\end{idleconsole}

Dans la pratique toutefois, cette forme est assez peu utile, on lui préfère\sidenote{Petite digression : à remarquer l'usage des parenthèses, qui permettent de couper la ligne en deux, car sinon le code serait trop long pour la \href{https://www.python.org/dev/peps/pep-0008/}{PEP8} (recommandations de style) ; on s'efforce toujours de ne pas dépasser 80 caractères de large, dans ce cas c'est utile notamment pour l'édition du document au format PDF.} souvent la \emph{liaison par nom}.

\begin{idleconsole}
\begin{pyconsole}
("{le_prenom} {le_nom} a {l_age} ans"
.format(le_nom=nom, le_prenom=prenom, l_age=age))
\end{pyconsole}
\end{idleconsole}

Dans ce premier exemple de liaison par nom, des noms différents ont été assignés pour les données externes et pour les noms apparaissant dans le format, pour bien illustrer comment la liaison se résout. %\\[1.5pt]
On peut cependant être plus direct et employer les mêmes appellations que les noms de variables.

\begin{idleconsole}
\begin{pyconsole}
("{prenom} {nom} a {age} ans"
.format(nom=nom, prenom=prenom, age=age))
\end{pyconsole}
\end{idleconsole}

\vspace{-0.5pt}

\paragraph{Formatage historique avec l'opérateur {\normalfont\texttt{\%}}}
La méthode \texttt{format} a été introduite assez tard dans \textsc{Python}. %, pour remplacer la technique présentée maintenant.
Étant donné le volume de code écrit avec l'opérateur \texttt{\%}, \nopagebreak il semble important d'introduire cette construction. On ne doit cependant pas utiliser cet opérateur dans du code moderne ; la bonne manière de formater les chaînes de caractères est désormais le \textit{f-string}.

Le principe de l'opérateur \texttt{\%} est d'élaborer comme précédemment un « format » c'est-à-dire le patron de ce qui doit être rendu, auquel on passe des arguments pour « remplir » les trous. Les exemples déjà formulés sont repris ci-dessous.

\begin{idleconsole}
	\begin{pyconsole}
		"%s %s a %s ans" % (prenom, nom, age)
	\end{pyconsole}
\end{idleconsole}

L'ancienne formulation est bien moins lisible que les autres approches. On pouvait également avec cet opérateur recourir à un mécanisme de liaison par nommage, en passant par un dictionnaire (notion abordée prochainement).

\begin{idleconsole}
	\begin{pyconsole}
		variables = {'le_nom': nom, 'le_prenom': prenom, 'l_age': age}
		"%(le_nom)s, %(le_prenom)s, %(l_age)s ans" % variables
	\end{pyconsole}
\end{idleconsole}

\vspace{1pt}

\overparagraph{Interaction avec l'utilisateur d'un programme}

Occasionnellement, il est nécessaire de poser une question à l'utilisateur. C'est tout le propos de la fonction \texttt{input}.

\begin{nbjupyterin}[before skip=4pt,after skip=1pt]{1}
nom_ville = input("Entrez le nom de la ville : ")
\end{nbjupyterin}
\begin{nbjupyterout}[after skip=4pt]{1}
Entrez le nom de la ville : Paris
\end{nbjupyterout}
\begin{nbjupyterin}[before skip=4pt,after skip=1pt]{2}
print(f"nom_ville = {nom_ville}")
\end{nbjupyterin}
\begin{nbjupyterout}[after skip=4pt]{2}
nom_ville = Paris
\end{nbjupyterout}

\begin{linewidthnote}
Il faut bien avoir conscience que la fonction \texttt{input} \emph{renvoie toujours une chaîne de caractères} (\texttt{str}). C'est assez évident, mais il est très facile de l'oublier et de passer cette chaîne directement à une fonction qui s'attend à recevoir, par exemple, un nombre entier, auquel cas les choses se passent mal. Dans un tel cas, il faut appeler la fonction \texttt{int} pour convertir le résultat en un entier.
\end{linewidthnote}

\begin{idleshell*}
Python 3.8.2 (default, Jul 16 2020, 14:00:26)\par
[GCC 9.3.0] on linux\par
Type "help", "copyright", "credits" or "license()" for more information.\par
\begin{lstlisting}[style=idlestyle,language=python,escapeinside=§§]
>>> input("nombre de lignes ? ") + 3
§\textcolor{blue}{nombre de lignes ?} 12§
§\textcolor{idleerrorcolor}{Traceback (most recent call last):}§
	§\textcolor{idleerrorcolor}{File "<pyshell\#0>", line 1, in <module>}§
    §\textcolor{idleerrorcolor}{input("nombre de lignes ? ") + 3}§
§\textcolor{idleerrorcolor}{TypeError: can only concatenate str (not "int") to str}§
>>> int(input("Nombre de lignes ? ")) + 3
§\textcolor{blue}{nombre de lignes ?} 12§
§\textcolor{blue}{15}§
\end{lstlisting}
\end{idleshell*}

La fonction \texttt{input} peut s'avérer bénéfique pour des premiers pas en \textsc{Python}. Néanmoins, on l'utilise peu car les applications « réelles » viennent avec leur propre interface --- souvent graphique --- et disposent donc d'autres moyens pour interagir avec l'utilisateur.

Quant à elles, les applications destinées à fonctionner dans un terminal reçoivent traditionnellement leurs données de la ligne de commande, fonctionnalité du module \texttt{argparse} déjà rencontré au chapitre précédent \qnameref{chap:X}.


\subsection[Compléments et application]{Compléments et application}
\label{sub:XI.1.2}


\subsubsection[Expressions régulières]{Expressions régulières}
\label{subsub:XI.1.2.1}

Une expression régulière\caution[t]<secondcolor>{Après avoir joué ce cours plusieurs années de suite, l'expérience montre qu'il est difficile de trouver le bon moment pour appréhender les expressions régulières.
D'un côté il s'agit de manipulations de chaînes de caractères, mais d'un autre cela nécessite de créer des instances de classes et par suite d'avoir vu la programmation orientée objet. Du coup, les premières années elle étaient étudiées à la fin du cours, engendrant une certaine frustration.
C'est pourquoi elle sont à présent introduite tôt, dans la séquence consacrée aux chaînes de caractères. Les étudiants qui seraient décontenancés par ce contenu sont invités à y retourner après la partie sur la programmation objet.
Il semble important de savoir que ces fonctionnalités existent dans le langage, le détail de leur utilisation n'est toutefois pas critique et on peut parfaitement faire l'impasse sur ce complément en première lecture.}{Avertissement des auteurs}
 est un objet mathématique qui décrit un ensemble de textes possèdant des propriétés communes. Par exemple, s'il arrive d'utiliser un terminal et que l'on saisisse \texttt{\$ ls *.txt} --- ou bien \texttt{\$ dir *.txt} sous \textsc{Windows} ---, l'expression régulière \texttt{*.txt} désigne tous les fichiers dont le nom se termine par \texttt{.txt}. On dit que l'expression régulière filtre toutes les chaînes qui se terminent par \texttt{.txt} --- la terminologie anglaise consacrée est le \textit{pattern matching}.

Le langage \textsc{Perl} a été le premier à populariser l'utilisation des expressions régulières en les supportant nativement et non pas au travers d'une librairie. En \textsc{Python}, les expressions régulières sont disponibles de manière plus traditionnelle, \textit{via} le module \texttt{re} (pour \textit{regular expressions}) de la librairie standard. Le propos de ce complément est d'en donner une première approche.

\begin{idleconsole}
	\begin{pyconsole}
		import re
	\end{pyconsole}
\end{idleconsole}

\overparagraph{Vue d'ensemble}

Pour le lecteur ne souhaitant pas approfondir, un premier exemple est proposé : on cherche à savoir si un objet chaîne est ou non de la forme \texttt{*-*.txt} et si oui, à calculer la partie qui remplace le « \texttt{*} ».

\begin{idleconsole}
	\begin{pyconsole}
		regexp = "(.*)-(.*)\.txt" # Objet expression régulière/pattern
		chaine = "abcdef.txt" # Chaîne de départ
		# Fonction qui calcule si la chaîne "matche" le pattern
		match = re.match(regexp, chaine)
		match is None
	\end{pyconsole}
\end{idleconsole}

Le fait que l'objet \texttt{match} vaut \texttt{None} indique que la chaîne n'est pas de la bonne forme (il manque un tiret « \texttt{-} » dans le nom). En revanche, cela correspond avec une autre chaîne.

\begin{idleconsole}
	\begin{pyconsole}
		chaine = "abc-def.txt" # Chaîne de départ
		# Fonction qui calcule si la chaîne "matche" le pattern
		match = re.match(regexp, chaine)
		match is None
	\end{pyconsole}
\end{idleconsole}

Ici \texttt{match} est un objet, qui permet ensuite « d'extraire » les différentes parties.

\begin{idleconsole}
	\begin{pyconsole}
		match[1]
		match[2]
	\end{pyconsole}
\end{idleconsole}

Bien entendu on peut s'attacher à des choses beaucoup plus élaborées avec \texttt{re}, mais en première lecture cette introduction doit suffire pour avoir une idée des possibilités avec les expressions régulières.

Avant de poursuivre, signalons qu'on emploie indifféremment les termes suivants pour désigner essentiellement la même chose :
\begin{itemize}
\item expression régulière ;
\item en anglais \textit{regular expression}, d'où le nom du module \texttt{re} ;
\item en anglais raccourci \textit{regexp}, \textit{de facto} devenu un nom commun ;
\item en français on trouve aussi parfois le terme d'\emph{expression rationnelle}, plus rare et un peu pédant ;
\item en anglais on utilise aussi facilement le terme de \textit{pattern} ;
\item qui, du coup, est traduit par \emph{motif}, d'un emploi assez rare.
\end{itemize}

Ensuite, selon les contextes, ces termes peuvent désigner des cho\-ses subtilement différentes ; par exemple pour distinguer la chaîne qui spécifie un \textit{pattern} de l'objet \textit{regexp} qui en est déduit, mais à ce stade de la présentation on peut signaler tous ces termes et les assimiler en gros à la même notion.

\overparagraph{Illustration par l'exemple}

Dans un terminal, \texttt{*.txt} est une expression régulière très simple. Le module \texttt{re}\sidenote{Il est conseillé de consulter la \href{https://docs.python.org/3/library/re.html}{documentation du module \texttt{re}} en parallèle de ce complément.} fournit le moyen de construire des expressions régulières très élaborées et plus puissantes que ce que supporte le terminal. C'est pourquoi la syntaxe des \textit{regexps} de \texttt{re} est un peu différente. Par exemple comme on vient de le voir, pour filtrer la même famille de chaînes que \texttt{*-*.txt} avec le module \texttt{re},\caution[t]<secondcolor>{Ce complément est amené à faire appel à des traits qui dépendent du \texttt{LOCALE}, c'est-à-dire de la configuration de l'ordinateur vis-à-vis de la langue. Il se peut que les résultats diffèrent légèrement en fonction de la station sur laquelle les codes sont exécutés. Pour ce document, la référence est un PC sous Ubuntu MATE 20.04 LTS configuré pour le français.}{Avertissement}
 il a fallu écrire l'expression régulière sous une forme légèrement différente.

\paragraph{Méthode {\normalfont\texttt{findall}}}
On se donne deux exemples de chaînes et on cherche tous les mots se terminant par « a » ou « m » dans une chaîne à l'aide de la méthode \texttt{findall}.

\begin{idleconsole}
	\begin{pyconsole}
sentences = ['Lacus a donec, vitae gravida proin sociis.', 
             'Neque ipsum! rhoncus cras quam.']
for sentence in sentences:
	print(f"---- dans >{sentence}<")
	print(re.findall(r"\w*[am]\W", sentence))

	\end{pyconsole}
\end{idleconsole}

Ce code permet de chercher toutes les occurrences de l'expression régulière, qui ici est définie par la chaîne : \lstinline[basicstyle={\small\shellttfont}]{r"\w*[am]\W"}.

Petite digression : cette manière de créer une chaîne en la préfixant par « \texttt{r} » s'appelle une \textit{raw-string} --- littéralement chaîne brute. L'intérêt est de ne pas interpréter les \textit{backslash}.
\begin{idleconsole}
	\begin{pyconsole}
		print("sans raw-string\nun newline")
		print(r"dans\nunraw-string")
	\end{pyconsole}
\end{idleconsole}

Dans une chaîne usuelle les caractères \textit{backslash} ont une signification particulière, mais quand on crée une expression régulière, le but est de laisser les \textit{backslashs} intacts, car c'est à la couche de \textit{regexp} de les interpréter.
Il n'y a aucune obligation à utiliser un \textit{raw-string}, d'ailleurs on note qu'il n'y a pas de différence de nature entre un \textit{raw-string} et une chaîne usuelle.

\begin{idleconsole}
	\begin{pyconsole}
raw = r'abc'
regular = 'abc'
# Comme on a pris une 'petite' chaîne ce sont les mêmes objets
print(f"both compared with is → {raw is regular}")
# et donc a fortiori
print(f"both compared with == → {raw == regular}")
	\end{pyconsole}
\end{idleconsole}

Il se trouve que le \textit{backslash} à l'intérieur des expressions régulières est d'un usage courant. C'est pourquoi on utilise fréquemment un \textit{raw-string} pour décrire une expression régulière. Il désactive l'interprétation des \textit{backslash} à l'intérieur de la chaîne. Par exemple, \lstinline[basicstyle={\small\shellttfont}]{\t} est interprété comme un caractère de tabulation dans une chaîne usuelle. Sans \textit{raw-string}, il faut doubler tous les \textit{backslash} pour qu'il n'y ait pas d'interprétation non voulue.

Ceci étant posé, on peut détailler la signification de l'expression régulière \lstinline[basicstyle={\small\shellttfont}]{r"\w*[am]\W"} :
\begin{itemize}
\item \lstinline[basicstyle={\small\shellttfont}]{\w*}, chercher une sous-chaîne qui commence par un nombre, y compris nul (\texttt{*}) de caractères alphanumériques (\lstinline[basicstyle={\small\shellttfont}]{\w}). Ceci est défini en fonction de la variable d’environnement \texttt{LOCALE} ;
\item \lstinline[basicstyle={\small\shellttfont}]{[am]}, immédiatement après, trouver un caractère « a » ou « m » ;
\item \lstinline[basicstyle={\small\shellttfont}]{\W}, et enfin, détecter un caractère \textit{qui ne soit pas alphanumérique}. Ceci est important puisqu'on cherche les mots qui se terminent par un « a » ou un « m », l'oublier fausserait le résultat.
\end{itemize}

\begin{idleconsole}
	\begin{pyconsole}
for sentence in sentences:
	print(f"---- dans >{sentence}<")
	print(re.findall(r"\w*[am]", sentence))

	\end{pyconsole}
\end{idleconsole}

\vspace{0.2\baselineskip}

\paragraph{Méthode {\normalfont\texttt{split}}}
Une autre forme simple d'utilisation des \textit{regexps} est la méthode \texttt{re.split}, qui fournit une fonctionnalité voisine de celle pour les chaîne de caractères \texttt{str.split}, mais ou les séparateurs sont exprimés comme une expression régulière.

\begin{idleconsole}
	\begin{pyconsole}
for sentence in sentences:
	print(f"---- dans >{sentence}<")
	print(re.split(r"\W+", sentence))

	\end{pyconsole}
\end{idleconsole}

Ici l'expression régulière, qui bien sûr décrit le séparateur, est simplement \lstinline[basicstyle={\small\shellttfont}]{\W+} c'est-à-dire toute suite d'au moins un caractère non alphanumérique. Cela offre là un moyen simple et plus puissant de couper un texte en mots que \texttt{str.split}.

\paragraph{Méthode {\normalfont\texttt{sub}}}
Une troisième méthode utilitaire est \texttt{re.sub} qui permet de remplacer les occurrences d'une \textit{regexp}.

\begin{idleconsole}
	\begin{pyconsole}
for sentence in sentences:
	print(f"---- dans >{sentence}<")
	print(re.sub(r"(\w+)", r"X\1Y", sentence))

	\end{pyconsole}
\end{idleconsole}

L'expression régulière (le premier argument) contient ici un groupe : on a utilisé des parenthèses autour du \lstinline[basicstyle={\small\shellttfont}]{\w+}. Le second argument est la chaîne de remplacement, dans laquelle on a fait référence au groupe en écrivant \lstinline[basicstyle={\small\shellttfont}]{\1}, qui veut dire tout simplement « le premier groupe ».
Donc au final, l'effet de cet appel est d'entourer toutes les suites de caractères alphanumériques par \lstinline[basicstyle={\small\shellttfont}]{X} et \lstinline[basicstyle={\small\shellttfont}]{Y}.

On regarde maintenant comment vérifier si une chaîne est conforme au critère défini par l'expression régulière, mais aussi extraire les morceaux de la chaîne qui correspondent aux différentes parties de l'expression. Pour ce faire, supposons qu'on s'intéresse aux chaînes qui comportent cinq parties : une suite de chiffres, une suite de lettres, des chiffres à nouveau, des lettres et enfin de nouveau des chiffres. On considère ces trois chaînes en entrée.

\begin{idleconsole}
	\begin{pyconsole}
samples = ['890hj000nnm890',   # Cette entrée convient
          '123abc456def789',   # Celle-ci aussi
          '8090abababab879',   # Celle-ci non
          ]
	\end{pyconsole}
\end{idleconsole}

\vspace{1pt}

\paragraph{Méthode {\normalfont\texttt{match}}}
Pour commencer, on peut facilement tester si une chaîne vérifie ou non le critère voulu. On applique l'expression régulière à toutes les entrées.

\begin{idleconsole*}
	\begin{pyconsole}
regexp1 = "[0-9]+[A-Za-z]+[0-9]+[A-Za-z]+[0-9]+"
for sample in samples:
    match = re.match(regexp1, sample)
    print(f"{sample:16} → {match}")

	\end{pyconsole}
\end{idleconsole*}

Pour rendre ce résultat plus lisible, on définit une petite fonction de confort, puis on relance l'essai.

\begin{idleconsole}
	\begin{pyconsole}
def nice(match): # Visualisation d'une correspondance
    # Le retour de re.match est soit None, soit un objet match
    return "No" if match is None else "Match!"

print(f"REGEXP={regexp1}\n")
for sample in samples:
    match = re.match(regexp1, sample)
    print(f"{sample:>16} → {nice(match)}")

	\end{pyconsole}
\end{idleconsole}

Ici plutôt que d'utiliser les raccourcis comme \lstinline[basicstyle={\small\shellttfont}]{\w}, on a préféré écrire explicitement les ensembles de caractères en jeu. De cette façon, on rend son code indépendant du \texttt{LOCALE} si c'est ce qu'on veut faire. Il y a deux morceaux qui interviennent tour à tour :
\begin{itemize}
\item \lstinline[basicstyle={\small\shellttfont}]{[0-9]+} une suite d'au moins un caractère dans l'intervalle \texttt{[0-9]},
\item \lstinline[basicstyle={\small\shellttfont}]{[A-Za-z]+} une suite d'au moins un caractère dans l'intervalle \texttt{[A-Z]} ou dans l'intervalle \texttt{[a-z]}.
\end{itemize}

Il est possible de nommer un morceau --- un groupe --- particulier de l'expression régulière pour convenance d'écriture ou de lecture. On se concentre sur une des deux entrées correctes et on appelle \texttt{needle} le groupe de chiffre central de l'expression régulière. Ce faisant, on peut demander de retrouver et imprimer la partie correspondante dans la chaîne initiale.

\begin{idleconsole}
	\begin{pyconsole}
haystack = samples[1]
haystack
regexp2 = "[0-9]+[A-Za-z]+(?P<needle>[0-9]+)[A-Za-z]+[0-9]+"
print(re.match(regexp2, haystack).group('needle'))
\end{pyconsole}
\end{idleconsole}

Dans l'expression ci-dessus, on a fait directement appel à un groupe nommé \lstinline[basicstyle={\small\shellttfont}]{(?P<needle>[0-9]+)}, dans lequel :
\begin{itemize}
\item les parenthèses définissent le groupe,
\item \lstinline[basicstyle={\small\shellttfont}]{?P<needle>} spécifie que ce groupe pourra être référencé\sidenote{Cette syntaxe très absconse est héritée semble-t-il de \textsc{Perl}.} sous le nom de \texttt{needle}.
\end{itemize}

Pour terminer avec les exemples, on aborde un trait qui n'est pas présent dans tous les langages, à savoir restreindre un morceau de chaîne à être identique à un groupe déjà vu plus tôt dans la chaîne. On peut donc ici ajouter comme contrainte que le premier et le dernier groupes de chiffres soient identiques.

Comme précédemment, on a défini le groupe nommé \texttt{id} comme étant la première suite de chiffres. La nouveauté est la contrainte imposée sur le dernier groupe avec \lstinline[basicstyle={\small\shellttfont}]{(?P=id)}. On n'obtient ainsi une correspondance qu'avec les entrées dans lesquelles le dernier groupe de chiffres est identique au premier.

\begin{idleconsole*}
	\begin{pyconsole}
regexp3 = "(?P<id>[0-9]+)[A-Za-z]+(?P<needle>[0-9]+)[A-Za-z]+(?P=id)"
print(f"REGEXP={regexp3}\n")
for sample in samples:
    match = re.match(regexp3, sample)
    print(f"{sample:>16} → {nice(match)}")

\end{pyconsole}
\end{idleconsole*}

\vspace{1pt}

\overparagraph{Compilation des expressions régulières}

Avant d'apprendre à écrire en propre une expression régulière, disons quelques mots du mode d'emploi de la bibliothèque.

\paragraph{Fonctions de commodité et \textit{workflow}}
Une expression régulière décrite sous forme de chaîne, comme par exemple \lstinline[basicstyle={\small\shellttfont}]{\w*[am]\W}, peut se traduire dans un \textit{automate fini} qui permet d'opérer le filtrage. Cela explique le \textit{workflow} résumé en \cref{fig:XI.2}.

\begin{figure}
\centering
\begin{tikzpicture}
%\draw[step=0.25cm, style=help lines, line width=0.1pt] (-5,-2.0) grid (5,2.0);
%\draw[step=1cm, style=help lines, line width=0.8pt] (-5,-2.0) grid (5,2.0);
%\node[draw] (string) at (-4,0) {\lstinline[basicstyle={\small\shellttfont}]{\w*[am]\W}};
\node[draw, font=\small] (string) at (-4,0.5) {\texttt{\textbackslash{w}*[am]\textbackslash{W}}};
\node[draw, font=\small] (regexobject) at (0,0.5) {RegexObject};
\node[draw, font=\small] (checkstring) at (0,-0.5) {Lacus a donec};
\node[draw, font=\small] (matchobject) at (4,-0.0) {MatchObject};
\draw[-latex, thick] (string.east) -- node[midway, fill=firstcolor, rounded corners=2pt, font=\footnotesize, yshift=12pt] 
	{\textcolor{white}{Compile}} (regexobject.west);
\draw[-latex, thick] (regexobject.east) -- ([yshift=-2pt]matchobject.north west);
\draw[-latex, thick] (checkstring.east) -- ([yshift=2pt]matchobject.south west);
\node[fill=firstcolor, rounded corners=2pt, font=\footnotesize, xshift=-2pt] at (2.0,-0.0) {\textcolor{white}{Match}};
\node[font=\scriptsize] at ([yshift=-12pt]string.south) 
	{\begin{tabular}{@{}c@{}}Chaîne qui\\ spécifie la regexp\end{tabular}};
\node[font=\scriptsize] at ([yshift=-8pt]checkstring.south) {Chaîne à vérifier};
\node[font=\small] at ([yshift=-10pt]matchobject.south) {(ou None)};
\end{tikzpicture}
\caption{\label{fig:XI.2}\emph{Workflow} d'une expression régulière.}
\end{figure}

Lorsqu'un même \textit{pattern} est à appliquer sur un grand nombre de chaînes, la méthode recommandée pour utiliser la bibliothèque est :
\begin{itemize}
\item de compiler \textit{une seule fois} la chaîne en automate, matérialisé par un objet de la classe \texttt{re.RegexObject}, en utilisant \texttt{re.compile} ;
\item puis d'\textit{employer cet objet} autant de fois qu'il y a de chaînes.
\end{itemize}

Des \textit{fonctions de commodité} du module ont été définies dans les exemples plus haut --- il en est de même par la suite pour une meilleure lisibilité. Elles sont pratiques, par exemple, pour mettre au point une expression régulière en mode interactif, mais ne sont \textit{pas forcément adaptées dans tous les cas}. 
Ces fonctions de commodité suivent toutes le même principe :\\[2pt]
\texttt{re.match(regexp, sample)} $\Leftrightarrow$ \texttt{re.compile(regexp).match(sample)}

Donc à chaque fois qu'on utilise une fonction de commodité, on recompile la chaîne en automate, ce qui, dès qu'on a plus d'une chaîne à traiter, représente un surcoût. La seconde version proposée ci-dessous ne compile qu'une fois la chaîne en automate et s'avère plus efficace.

\begin{idleconsole*}
	\begin{pyconsole}
for sample in samples: # Imaginer 10**6 chaînes dans samples
    match = re.match(regexp3, sample)
    print(f"{sample:>16} → {nice(match)}")

re_obj3 = re.compile(regexp3) # On compile la chaîne en automate une seule fois,
for sample in samples:        # ensuite on part directement de l'automate
    match = re_obj3.match(sample)
    print(f"{sample:>16} → {nice(match)}")

\end{pyconsole}
\end{idleconsole*}

\vspace{1pt}

\paragraph{Méthodes sur la classe {\normalfont\texttt{RegexObject}}}
Les objets de la classe \texttt{RegexObject} représentent donc l'automate à état fini qui est le résultat de la compilation de l'expression régulière. Pour résumer ce qu'on a déjà vu, les méthodes les plus utiles sur un objet \texttt{RegexObject} sont :
\begin{itemize}
\item \texttt{match} et \texttt{search}, qui cherchent une correspondance soit uniquement au début (\texttt{match}) ou n'importe où dans la chaîne (\texttt{search}),
\item \texttt{findall} et \texttt{split} pour chercher toutes les occurrences (\texttt{findall}) ou leur négatif (\texttt{split}),
\item \texttt{sub} (qui aurait pu sans doute s'appeler \texttt{replace}, mais c'est ainsi) pour remplacer les occurrences de \textit{pattern}.
\end{itemize}

\paragraph{Méthodes sur la classe {\normalfont\texttt{re.MatchObject}}}
Pour exploiter les résultats, les méthodes disponibles sur la classe \texttt{re.MatchObject} sont \href{https://docs.python.org/3/library/re.html#match-objects}{documentées en détail}. On en a déjà rencontré quelques-unes, en voici à nouveau un aperçu rapide :
\begin{itemize}
\item  les méthodes \texttt{re} et \texttt{string} pour retrouver les données d'entrée du \texttt{match} ;
\item  les méthodes \texttt{group}, \texttt{groups}, \texttt{groupdict} pour retrouver les morceaux de la chaîne d'entrée qui correspondent aux groupes de la \textit{regexp}. On peut y accéder\sidenote{Comme vu plus haut avec \texttt{needle}.} par rang ou par nom.
\end{itemize}

\begin{idleconsole}
	\begin{pyconsole}
sample = "    Isaac Newton, physicist"
match = re.search(r"(\w+) (?P<name>\w+)", sample)
match.string
match.re
match.groups()
match.group(1)
match.group('name')
match.group(2)
match.groupdict()
	\end{pyconsole}
\end{idleconsole}

Comme on le voit pour l'accès par rang, les indices commencent à $1$ pour des raisons\sidenote{On pouvait déjà référencer \lstinline[basicstyle={\small\shellttfont}]{\1} dans l'éditeur \textsc{Unix} \texttt{sed} à la fin des années 1970 !} historiques. 
On peut aussi accéder au groupe $0$ comme étant la partie de la chaîne de départ qui a effectivement été filtrée par l'expression régulière et qui, en général, est une sous-chaîne de la chaîne de départ.

\begin{idleconsole}
	\begin{pyconsole}
match.group(0) # La sous-chaîne filtrée
sample # La chaîne de départ
	\end{pyconsole}
\end{idleconsole}

On trouve également la méthode \texttt{expand} qui permet de faire une espèce de \texttt{str.format} avec les valeurs des groupes et la méthode \texttt{span} pour connaître les index dans la chaîne d'entrée pour un groupe donné.

\begin{idleconsole}
	\begin{pyconsole}
match.expand(r"last_name \g<name> first_name \1")
sample # La chaîne de départ
begin, end = match.span('name')
sample[begin:end]
	\end{pyconsole}
\end{idleconsole}

\textit{Nota bene} : \texttt{seq[i:j]} est une opération de \textit{slicing}\sidenote{Notion abordé par la suite.} --- littéralement « trancher-partager » --- qui retourne une séquence contenant les éléments de \texttt{i} à \texttt{j-1} de \texttt{seq}.

\paragraph{Différents modes (\textit{flags})}
Il faut également noter qu'on peut passer à \texttt{re.compile} un certain nombre de \textit{flags} --- littéralement « drapeaux » --- qui modifient globalement l'interprétation de la chaîne de caractères et qui peuvent rendre service.

La liste exhaustive de ces \textit{flags} est disponible dans la \href{https://docs.python.org/3/library/re.html#module-contents}{documentation}. Ils ont en général un nom long et parlant, et un alias court sur un seul caractère. Les plus utiles sont sans doute :
\begin{itemize}
\item \texttt{IGNORECASE} (alias I) pour ne pas faire de différence entre minuscules et majuscules ;
\item \texttt{UNICODE} (alias U) pour rendre les séquences \lstinline[basicstyle={\small\shellttfont}]{\w} et autres basées sur les propriétés des caractères dans la norme Unicode ;
\item \texttt{LOCALE} (alias L) cette fois \lstinline[basicstyle={\small\shellttfont}]{\w} dépend de la langue courante ;
\item \texttt{MULTILINE} (alias M)\caution[b]<firstcolor>{Pour les \textit{flags} \texttt{MULTILINE} et \texttt{DOTALL}, la rédaction n'a pas compris le texte initial des auteurs faisant référence à une discussion dans la suite du document ; elle s'est contentée de reproduire la documentation.}{Note de la rédaction} pour les \textit{patterns} de début et fin de ligne ;
\item et \texttt{DOTALL} (alias S), pour faire du point « . » une correspondance avec tous les caractères, y compris une fin de ligne.
\end{itemize}
Comme c'est souvent le cas, on doit passer à \texttt{re.compile} un « OU » logique (caractère \texttt{|} ou « \textit{pipe} ») des différents \textit{flags} que l'on veut utiliser, c'est-à-dire comme suit.

\begin{idleconsole*}
	\begin{pyconsole}
regexp = "a*b+"
re_obj = re.compile(regexp, flags=re.IGNORECASE | re.DEBUG)
print(regexp, "->", nice(re_obj.match("AabB"))) # On ignore la casse des caractères
	\end{pyconsole}
\end{idleconsole*}

\vspace{1pt}

\overparagraph{Construction d'une expression régulière}

L'élaboration d'une expression régulière se veut ici synthétique (la \href{https://docs.python.org/3/library/re.html}{documentation du module \texttt{re}} en donne une version exhaustive).

La brique de base est le caractère quel qu'il soit et plusieurs approches sont alors possibles :
\begin{itemize}
\item un \emph{seul} caractère, à citer tel quel, en le précédent d'un \textit{backslash} « \texttt{\textbackslash} » s'il a par ailleurs un sens spécial dans le micro-langage de \textit{regexps} (comme « \texttt{+} », « \texttt{*} », « \texttt{[} », etc.) ;
\item l'\emph{attrape-tout} (\textit{wildcard}), un point « \texttt{.} » signifie « n'importe quel caractère » ;
\item un \emph{ensemble} de caractères avec la notation \texttt{[...]} qui permet de décrire par exemple :
	\begin{itemize}\jazzitem
	\item \lstinline[basicstyle={\small\shellttfont}]{[a1=]} un ensemble \textit{in extenso}, ici un caractère parmi « \texttt{a} », «~\texttt{1}~» ou « \texttt{=} »,
	\item \lstinline[basicstyle={\small\shellttfont}]{[a-z]} un intervalle de caractères, ici de « \texttt{a} » à « \texttt{z} »,
	\item \lstinline[basicstyle={\small\shellttfont}]{[15e-g]} un mélange des deux, ici un ensemble qui contiendrait « \texttt{1} », « \texttt{5} », « \texttt{e} », « \texttt{f} » et « \texttt{g} »,
	\item \lstinline[basicstyle={\small\shellttfont}]{[^15e-g]} une négation, qui a « \texttt{\textasciicircum{}} » comme premier caractère dans les crochets, ici tout sauf l'ensemble précédent;
	\end{itemize}
\item un \emph{ensemble prédéfini} de caractères, lesquels peuvent alors dépendre de l'environnement (\texttt{UNICODE} et \texttt{LOCALE}) avec entre autres les notations:
	\begin{itemize}\jazzitem
	\item \lstinline[basicstyle={\small\shellttfont}]{\w} les caractères alphanumériques et \lstinline[basicstyle={\small\shellttfont}]{\W} (les autres),
	\item \lstinline[basicstyle={\small\shellttfont}]{\s} les caractères "blancs" - espace, tabulation, saut de ligne, etc. et \lstinline[basicstyle={\small\shellttfont}]{\S} (les autres),
	\item \lstinline[basicstyle={\small\shellttfont}]{\d} pour les chiffres et \lstinline[basicstyle={\small\shellttfont}]{\D} (les autres).
	\end{itemize}
\end{itemize}

\begin{idleconsole*}
	\begin{pyconsole}
sample = "abcd"
for regexp in ['abcd', 'ab[cd][cd]', 'ab[a-z]d', r'abc.', r'abc\.']:
    match = re.match(regexp, sample)
    print(f"{sample} / {regexp:<10s} → {nice(match)}")%

print(nice(re.match (r"abc\.", "abc.")))
	\end{pyconsole}
\end{idleconsole*}

Pour ce dernier exemple, comme un \textit{backslash} est ajouté devant le point (« \texttt{.} »), il faut que la chaîne d'entrée contienne vraiment un point.

\paragraph{En série ou bien en parallèle}
Par analogie avec les montages électriques, on a vu jusqu'ici le montage en série : les expressions régulières sont mises bout à bout et filtrent (\texttt{match}) séquentiellement la chaîne en entrée du début à la fin. On a \emph{un peu} de marge pour spécifier des alternatives, lorsqu'on fait par exemple \lstinline[basicstyle={\small\shellttfont}]{"ab[cd]ef"}, mais c'est limité à \emph{un seul} caractère. Si on veut reconnaître deux mots qui n'ont pas grand-chose à voir comme \texttt{abc} ou \texttt{def}, il faut en quelque sorte mettre deux \textit{regexps} en parallèle, c'est ce que permet l'opérateur « \texttt{|} ».

\begin{idleconsole}
	\begin{pyconsole}
regexp = "abc|def"

for sample in ['abc', 'def', 'aef']:
    match = re.match(regexp, sample)
    print(f"{sample} / {regexp} → {nice(match)}")

	\end{pyconsole}
\end{idleconsole}

\vspace{1pt}

\paragraph{Fin(s) de chaîne}
Selon que l'on utilise \texttt{match} ou \texttt{search}, on précise si on s'intéresse uniquement à une correspondance en début (\texttt{match}) de chaîne ou n'importe où (\texttt{search}) dans la chaîne.

Mais indépendamment de cela, il peut être intéressant de « coller » l'expression en début ou en fin de ligne. Pour ce faire, il existe des caractères spéciaux :
\begin{itemize}
\item \lstinline[basicstyle={\small\shellttfont}]{^} lorsqu'il est utilisé comme un caractère (c'est à dire pas en début de \texttt{[]}) signifie un début de chaîne;
\item \lstinline[basicstyle={\small\shellttfont}]{\A} a le même sens (sauf en mode \texttt{MULTILINE}), recommandé de préférence à \texttt{\textasciicircum} qui est déjà pas mal surchargé;
\item \lstinline[basicstyle={\small\shellttfont}]{$} correspond à une fin de ligne;
\item \lstinline[basicstyle={\small\shellttfont}]{\Z} est voisin de \texttt{\$} mais pas tout à fait identique.
\end{itemize}

Se reporter à la documentation pour le détail des différences. Attention aussi à entrer le \texttt{\textasciicircum} correctement, il faut le caractère ASCII et non un voisin dans la ménagerie Unicode.

\begin{idleconsole}
	\begin{pyconsole}
sample = 'abcd'
for regexp in [ r'bc', r'\Aabc', r'^abc', 
                r'\Abc', r'^bc', r'bcd\Z', 
                r'bcd$', r'bc\Z', r'bc$' ]:
    match = re.match(regexp, sample)
    search = re.search(regexp, sample)
    print(f"{sample} / {regexp:5s} match → {nice(match):6s},"
          f" search → {nice(search)}")

	\end{pyconsole}
\end{idleconsole}

On a en effet bien le \textit{pattern} \texttt{bc} dans la chaîne en entrée, mais il n'est ni au début ni à la fin.

\paragraph{Parenthésage ou groupement}
Pour pouvoir faire des montages élaborés, il faut pouvoir introduire des parenthésages.

\begin{marginfigure}
\centering
\begin{tikzpicture}
%\draw[step=0.25cm, style=help lines, line width=0.1pt] (-2.5,-1.0) grid (2.5,1.0);
%\draw[step=1cm, style=help lines, line width=0.8pt] (-2.5,-1.0) grid (2.5,1.0);
\node[fill=maincolor, font=\small, rounded corners=2pt] (a) at (-2.0,0.0) {\texttt{a}};
\node[fill=maincolor, font=\small, rounded corners=2pt] (bc) at (0,0.5) {\texttt{bc}};
\node[fill=maincolor, font=\small, rounded corners=2pt] (de) at (0,-0.5) {\texttt{de}};
\node[fill=maincolor, font=\small, rounded corners=2pt] (f) at (2,-0.0) {\texttt{f}};
\draw[-latex, thick] ([yshift=2pt]a.east) -- ([yshift=2pt]bc.south west);
\draw[-latex, thick] ([yshift=-2pt]a.east) -- ([yshift=-2pt]de.north west);
\draw[-latex, thick] ([yshift=2pt]bc.south east) -- ([yshift=2pt]f.west);
\draw[-latex, thick] ([yshift=-2pt]de.north east) -- ([yshift=-2pt]f.west);
\end{tikzpicture}
\caption{\label{fig:XI.3}Flux avec parenthésage.}
\end{marginfigure}

\begin{idleconsole}
	\begin{pyconsole}
# Parenthèses dans une RE pour mettre en ligne :
# un début 'a', un milieu 'bc' ou 'de' et une fin 'f'
regexp = "a(bc|de)f"
for sample in ['abcf', 'adef',  'abef', 'abf']:
    match = re.match(regexp, sample)
    print(f"{sample:>4s} → {nice(match)}")

	\end{pyconsole}
\end{idleconsole}

Les parenthèses jouent un rôle additionnel de groupe, ce qui signifie qu'on peut retrouver le texte correspondant à l'expression régulière comprise dans les parenthèses. 

Ainsi, pour la première correspondance de l'exemple ci-dessus, on n'a utilisé qu'un seul groupe de parenthèse « \texttt{()} » et le morceau de chaîne qui correspond à ce groupe se trouve donc être le seul groupe retourné par \texttt{MatchObject.group}.

\begin{idleconsole}
	\begin{pyconsole}
sample = 'abcf'
match = re.match(regexp, sample)
print(f"{sample}, {regexp} → {match.groups()}")
	\end{pyconsole}
\end{idleconsole}

\paragraph{Compter les répétitions}
Pour gérer les répétitions, on dispose des opérateurs suivants :
\begin{itemize}
\item \texttt{*} l'étoile signifiant n'importe quel nombre d'occurrences, même nul --- par ex., \texttt{(ab)*} pour indiquer \texttt{''} ou \texttt{'ab'} ou \texttt{'abab'} ou etc. ;
\item \texttt{+} le plus qui signifie au moins une occurrence --- c.-à.-d. \texttt{(ab)+} pour \texttt{ab} ou \texttt{abab} ou \texttt{ababab} ou etc. ;
\item \texttt{?} qui indique une option, c'est-à-dire zéro ou une occurrence --- autrement dit \texttt{(ab)?} \textit{matche} \texttt{''} ou \texttt{ab} ;
\item \texttt{\{n\}} pour exactement \texttt{n} occurrences de \texttt{(ab)} --- c.-à.-d. \texttt{(ab){3}} qui serait exactement équivalent à \texttt{ababab} ;
\item \texttt{\{m,n\}} entre \texttt{m} et \texttt{n} fois inclusivement.
\end{itemize}

\begin{idleconsole*}
	\begin{pyconsole}
# NB: la construction [op(elt) for elt in iterable] est une compréhension de liste étudiée plus tard.
# Elle retourne une liste des résultats de l'opération op sur chaque élément de la liste de départ
samples = [n*'ab' for n in [0, 1, 3, 4]] + ['baba']
for regexp in ['(ab)*', '(ab)+', '(ab){3}', '(ab){3,4}']:
    # on ajoute \textbackslash{A} \textbackslash{Z} pour matcher toute la chaîne
    line_regexp = r"\A{}\Z".format(regexp)
    for sample in samples:
        match = re.match(line_regexp, sample)
        print(f"{sample:>8s} / {line_regexp:14s} → {nice(match)}")

\end{pyconsole}
\end{idleconsole*}

\vspace{1pt}

\paragraph{Groupes et contraintes}
On a déjà vu un exemple de groupe nommé (voir \texttt{needle} plus haut). Les opérateurs de cette catégorie sont :
\begin{itemize}
\item \texttt{(...)} les parenthèses définissent un groupe anonyme ;
\item \texttt{(?P<name>...)} définit un groupe nommé ;
\item \texttt{(?:...)} permet de mettre des parenthèses mais sans créer un groupe, pour optimiser l'exécution puisqu'on n'a pas besoin de conserver les liens vers la chaîne d'entrée ;
\item \texttt{(?P=name)} qui ne \textit{matche} que si l'on retrouve à cet endroit de l'entrée la même sous-chaîne que celle trouvée pour le groupe \texttt{name} en amont ;
\item enfin \texttt{(?=...)}, \texttt{(?!...)} et \texttt{(?<=...)} permettent des contraintes encore plus élaborées, est laissé au lecteur le soin d'expérimenter ces possibilités ; à savoir toutefois que l'utilisation de telles constructions peut en théorie rendre l'interprétation de l'expression régulière beaucoup moins efficace.
\end{itemize}

\paragraph{\textit{Greedy} \textit{versus} non-\textit{greedy}}
Lorsqu'on stipule une répétition un nombre indéfini de fois, il se peut qu'il existe plusieurs façons de filtrer l'entrée avec l'expression régulière. Que ce soit avec \texttt{*}, \texttt{+} ou \texttt{?}, l'algorithme va toujours essayer de trouver la séquence la plus longue, c'est pourquoi on qualifie l'approche de \textit{greedy} --- quelque chose comme « \emph{glouton} » en français.

\begin{idleconsole*}
	\begin{pyconsole}
line='<h1>Title</h1>' # Fragment d'HTML
# Si on cherche un texte quelconque entre crochets c'est-à-dire l'expression régulière « <.*> »
re_greedy = '<.*>'
# On obtient ceci, on rappelle que group(0) montre la partie du fragment HTML qui matche la regexp
match = re.match(re_greedy, line)
match.group(0)
	\end{pyconsole}
\end{idleconsole*}

Cela n'est pas forcément ce qu'on voulait faire, aussi on peut spécifier l'approche inverse, c'est-à-dire trouver la plus-petite chaîne qui \textit{matche}, dans une approche dite non-\textit{greedy}, avec les opérateurs :
\begin{itemize}\jazzitem
\item \texttt{*? : *} mais non-\textit{greedy} ;
\item \texttt{+? : +} mais non-\textit{greedy} ;
\item \texttt{?? : ?} mais non-\textit{greedy}.
\end{itemize}

\begin{idleconsole*}
	\begin{pyconsole}
# Ici on va remplacer * par *? pour rendre l'opérateur * non-greedy
re_non_greedy = re_greedy = '<.*?>'
# Mais on continue à cherche un texte entre <> naturellement si bien que cette fois, on obtient
match = re.match(re_non_greedy, line)
match.group(0)
	\end{pyconsole}
\end{idleconsole*}

\vspace{-1pt}

\paragraph{Traitement des fins de ligne}
Il peut être utile, pour con\-clure cette présentation des expressions régulières, de préciser un peu le comportement de la bibliothèque vis-à-vis des fins de ligne.

Historiquement, les expressions régulières telles qu'on les trouve dans les bibliothèques C, donc dans \texttt{sed}, \texttt{grep} et autre utilitaires \textsc{Unix}, sont associées au modèle mental où on filtre les entrées ligne par ligne.
Le module \texttt{re} en garde des traces.

\begin{idleconsole}
	\begin{pyconsole}
# Exemple de traitement des `newlines'
sample = """une entrée 
sur
plusieurs
lignes
"""
match = re.compile("(.*)").match(sample)
match.groups()
\end{pyconsole}
\end{idleconsole}

On voit donc que l'attrape-tout \texttt{'.'} en fait ne recueille pas le caractère de fin de ligne \texttt{\textbackslash{n}}, puisque si c'était le cas et compte tenu du coté \textit{greedy} de l'algorithme, on devrait voir ici tout le contenu de \texttt{sample}. Il existe un \textit{flag} \texttt{re.DOTALL} qui permet de faire du point un vrai attrape-tout qui capture aussi les instructions de nouvelle ligne.

\begin{idleconsole}
	\begin{pyconsole}
match = re.compile("(.*)", flags=re.DOTALL).match(sample)
match.groups()
\end{pyconsole}
\end{idleconsole}

Cela dit, le caractère \textit{newline} est par ailleurs considéré comme un autre, on peut le mentionner dans une \textit{regexp} comme les autres. Voici quelques exemples pour illustrer tout ceci.

\begin{idleconsole*}
	\begin{pyconsole}
# Depuis Python 3, sans mettre de flag, \textbackslash{w} matche l'Unicode
match = re.compile("([\w ]*)").match(sample)
match.groups()
# Pour matcher les caractères ASCII avec \textbackslash{w}, il faut mentionner le flag ASCII re.A
match = re.compile("([\w ]*)", flags=re.A).match(sample)
match.groups()
# Si on ajoute \textbackslash{n} à la liste des caractères attendus, on obtient bien tout le contenu initial
match = re.compile("([\w \n]*)", flags=re.UNICODE).match(sample)
match.groups()
	\end{pyconsole}
\end{idleconsole*}

\vspace{1pt}

\paragraph{Conclusion}
La mise au point d'expressions régulières est certes un peu exigeante et demande pas mal de pratique, mais permet d'écrire en quelques lignes des fonctionnalités\sidenote{C'est un investissement très rentable !} très puissantes.

On peut enfin mentionner l'existence de sites Web qui évaluent une expression régulière de manière interactive et qui peuvent rendre la mise au point moins\sidenote{Notamment \url{https://pythex.org/} ou \url{https://regex101.com}.} fastidieuse.

%Un élève, qui a eu notamment des soucis avec le \texttt{\textbackslash{w}} sur \url{pythex.org} (dont, on l'a vu, la signification dépend du \texttt{LOCALE} de la machine hôte) recommande pour sa part \url{https://regex101.com}
%Ce site est très didactique et lui reconnaît les caractères accentués sur un \w sans rajouter de flag (même si cette option est possible).

\paragraph{Pour en savoir plus}
Pour ceux qui ont quelques rudiments de la théorie des langages, il est connu qu'on distingue en général :
\begin{itemize}
\item l'\emph{analyse lexicale}, qui découpe le texte en morceaux (qu'on appelle des \textit{tokens}) ;
\item et l'\emph{analyse syntaxique} qui décrit pour simplifier à l'extrême, l'or\-dre dans lequel on peut trouver les \textit{tokens}.
\end{itemize}

Avec les expressions régulières, on adresse le niveau de l'analyse lexicale. Pour l'analyse syntaxique, franchement au delà des objectifs de ce cours, il existe de nombreuses alternatives, parmi lesquelles:
\begin{itemize}
\item \textsc{pyparsing} ;
\item \textsc{PLY} (\href{http://www.dabeaz.com/ply/}{Python Lex-Yacc}) ;
\item \textsc{ANTLR}, outil écrit en \textsc{Java} qui peut générer des \textit{parsers} \textsc{Python}.
\end{itemize}


\subsubsection[Exercices]{Exercices}
\label{subsub:XI.1.2.2}

Sont ici proposés quelques exercices sur les expressions régulières. Quelques remarques\sidenote{Pour ces exercices, il peut être profitable d'avoir sous la main :
\begin{sideitemize}
\item la documentation officielle ;
\item l'accès à un site qui permet de mettre au point la \textit{regexp} de manière interactive et rapide (cf. note précédente).
\end{sideitemize}
} avant de commencer :
\begin{itemize}
\item on se concentre sur l'écriture de l'expression régulière en elle-même, non pas sur l'utilisation de la bibliothèque ;
\item en particulier, tous les exercices font appel à \texttt{re.match} entre la \textit{regexp} à élaborer et une chaîne d'entrée qui sert de jeux de test.
\end{itemize}


%\vspace{\baselineskip}

\begin{exercise}[title=Identificateurs Python, level=intermediate]
Il est demandé d'écrire une expression régulière qui décrit les noms de variable en \textsc{Python}. Pour cet exercice on se concentre uniquement sur les caractères ASCII. On exclut donc les noms de variables qui pourraient contenir des caractères exotiques comme les caractères accentués ou encore les lettres grecques.

Il s'agit donc de reconnaître toutes les chaînes qui commencent par une lettre ou un \textit{underscore} « \texttt{\_} », suivi de lettres, chiffres ou d'autres \textit{underscore}. Le tableau qui suit en donne quelques exemples.

\vspace{2pt}

\begin{jazztable}
\caption{\label{tab:XI.1}Exemple de chaînes commençant par une lettre ou un \emph{underscore}.}
\begin{center}
\small
%\centering
\renewcommand*{\arraystretch}{1.4}
\rowcolors{2}{tableLineOne}{tableLineTwo}
\begin{tabularx}{0.6666\linewidth}{YYYY}
\rowcolor{secondcolor}
%\multicolumn{2}{c}{\Gape[6pt]{\textcolor{white}{\normalfont\textbf{}}}} \\
%\rowcolor{firstcolor}
\multicolumn{1}{c}{\Gape[6pt]{\textcolor{white}{\textbf{Chaîne}}}}	&
\multicolumn{1}{c}{\Gape[6pt]{\textcolor{white}{\textbf{Match ?}}}} &
\multicolumn{1}{c}{\Gape[6pt]{\textcolor{white}{\textbf{Chaîne}}}}	&
\multicolumn{1}{c}{\Gape[6pt]{\textcolor{white}{\textbf{Match ?}}}} \\
\texttt{'a'}		& Vrai & \texttt{' '}		& Vrai \\
\texttt{'-'}		& Faux & \texttt{'\_\_'}& Vrai \\
\texttt{'aa1'}	& Vrai & \texttt{'A1a'}	& Vrai \\
\texttt{'1Aa'}	& Faux & \texttt{'-aa1'}& Faux \\
\end{tabularx}%
\end{center}
\vspace{2pt}
\end{jazztable}
\end{exercise}

\begin{exercise}[title=Lignes avec nom et prénom, level=intermediate]
On veut reconnaître dans un fichier toutes les lignes qui contiennent un nom et un prénom.
Plus précisément, on cherche les chaînes qui :
\begin{itemize}
\item commencent par une suite de caractères alphanumériques (on peut utiliser l'instruction « \texttt{\textbackslash{w}} » ou tiret haut « \texttt{-} » qui constitue le prénom ;
\item contiennent ensuite comme séparateur le caractère deux-points « \texttt{:} » ;
\item contiennent ensuite une suite --- cette fois jamais vide --- de caractères alphanumériques, qui constitue le nom ;
\item et enfin contiennent un deuxième « \texttt{:} » mais en option seulement.
\end{itemize}


On demande de construire une expression régulière définissant les deux groupes \texttt{nom} et \texttt{prenom} et rejetant les lignes qui ne satisfont pas ces critères.

Dans la correction --- et ce sera pareil pour tous les exercices avec des groupes --- la correction affiche \emph{uniquement les groupes demandés} ; ici on va montrer les groupes \texttt{nom} et \texttt{prenom}. On a parfaitement le droit d'utiliser des groupes supplémentaires, nommés ou pas, dans la \textit{regexp}.
\end{exercise}

\begin{exercise}[title=Numéros de téléphone, level=intermediate]
On veut reconnaître des numéros de téléphone français :
\begin{itemize}
\item soit au format contenant 10 chiffres dont le premier est un 0 ;
\item soit au format international commençant par +33 suivi de 9 chiffres.
\end{itemize}

Dans tous les cas on veut trouver dans le groupe \texttt{number} les 9 chiffres vraiment significatifs. 
%, comme dans le tableau à suivre.

%\vspace{.5\baselineskip}
%\begin{jazztable}
%\caption{\label{tab:XI.2}Numéro de téléphone : chiffres significatifs.}
%\begin{center}
%\small
%\renewcommand*{\arraystretch}{1.6}
%\rowcolors{2}{tableLineOne}{tableLineTwo}
%\begin{tabularx}{\linewidth}{YYYY}
%\rowcolor{secondcolor}
%%\multicolumn{2}{c}{\Gape[6pt]{\textcolor{white}{\normalfont\textbf{}}}} \\
%%\rowcolor{firstcolor}
%\multicolumn{1}{c}{\Gape[6pt]{\textcolor{white}{\textbf{Chaîne}}}}	&
%\multicolumn{1}{c}{\Gape[6pt]{\textcolor{white}{\textbf{Groupe}}}} &
%\multicolumn{1}{c}{\Gape[6pt]{\textcolor{white}{\textbf{Chaîne}}}}	&
%\multicolumn{1}{c}{\Gape[6pt]{\textcolor{white}{\textbf{Groupe}}}} \\
%\texttt{'0123456789'}		& [('number', '123456789')] & \texttt{'01234567890'} & None \\
%\texttt{'012345678'}		& None & \texttt{'1234567890'}& None \\
%\texttt{'33123456789'}	& None & \texttt{'+3312345678'}	& [('number', '123456789')] \\
%%\texttt{'330123456789'}	& None & &  \\
%\end{tabularx}%
%\end{center}
%\end{jazztable}

\end{exercise}


Vu comment sont conçus les exercices, on ne peut pas passer à la méthode \texttt{re.compile} un drapeau\sidenote{Pour plus de précisions sur ce trait --- laissé de côté pour ne pas trop alourdir le complément ---, voir la documentation sur les expressions régulières et cherchez la première occurrence de \texttt{iLmsux}.} comme \texttt{re.IGNORECASE} ou autre. 
Cependant, on peut embarquer ces drapeaux dans la \textit{regexp} elle-même ; par exemple pour la rendre insensible à la casse de caractères, au lieu d'appeler \texttt{re.compile} avec le \textit{flag} \texttt{re.I}, on utilise \texttt{(?i)} comme suit.

\begin{idleconsole*}[before skip=10pt]
	\begin{pyconsole}
import re
# On peut embarquer les flags comme IGNORECASE directement dans la regexp, équivalent de faire ceci
re_obj = re.compile("abc", flags=re.IGNORECASE)
re_obj.match("ABC").group(0)
re.match("(?i)abc","ABC").group(0) # ou de faire cela
# Les flags comme (?i) doivent apparaître en premier dans la regexp
re.match("abc(?i)","ABC").group(0)
	\end{pyconsole}
\end{idleconsole*}

%	\end{pyconsole}
%\end{idleconsole}
%\end{fullwidth}
%\begin{fullwidth}
%\begin{idleconsole}[after skip=6pt]
%	\begin{pyconsole}

%Pour plus de précisions sur ce trait --- laissé de côté pour ne pas trop alourdir le complément ---, voir la documentation sur les expressions régulières et cherchez la première occurrence de \texttt{iLmsux}.

%\vspace*{4pt}

\begin{exercise}[title=Décortiquer une URL, level=advanced]
On demande d'écrire une expression régulière qui permette d'analyser des URLs.
Voici les conventions adoptées pour l'exercice :
\begin{itemize}
\item la chaîne contient les parties \texttt{<protocol>://<location>/<path>} ;
\item l'URL commence par le nom d'un protocole qui doit être parmi \texttt{http}, \texttt{https}, \texttt{ftp}, \texttt{ssh} ;
\item le nom du protocole peut contenir de manière indifférente des minuscules ou des majuscules ;
\item ensuite doit venir la séquence « \texttt{://} » ;
\item ensuite on va trouver une chaîne \texttt{<location>} qui contient :
	\begin{itemize}\jazzitem
  	\item potentiellement un nom d'utilisateur et s'il est présent, potentiellement un mot de passe ;
    \item obligatoirement un nom de \texttt{hostname} ;
    \item potentiellement un numéro de port ;
  \end{itemize}
\item lorsque les quatre parties sont présentes dans \texttt{<location>}, cela fournit : 
	\texttt{<location> = <user>:<password>@<hostname>:<port>} ;
\item si l'on note entre crochets les parties optionnelles, cela donne :\\
	\texttt{<location> = [<user>[:<password>]@]<hostname>[:<port>]} ;
\item le champ \texttt{<user>} ne peut contenir que des caractères alphanumériques ; si le \texttt{@} est présent, le champ \texttt{<user>} ne peut pas être vide ;
\item le champ \texttt{<password>} peut contenir tout sauf un « \texttt{:} » et de même, si le « \texttt{:} » est présent le champ \texttt{<password>} ne peut pas être vide ;
\item le champ \texttt{<hostname>} peut contenir une suite non-vide de caractères alphanumériques, \textit{underscores}, ou « \texttt{.} » ;
\item le champ \texttt{<port>} ne contient que des chiffres et est non vide si le «~\texttt{:}~» est spécifié ;
\item le champ \texttt{<path>} peut être vide.
\end{itemize}

%Enfin, il faut définir les groupes \texttt{proto}, \texttt{user}, \texttt{password}, \texttt{hostname}, \texttt{port} et \texttt{path} utilisés pour vérifier le résultat. Dans la case des résultats attendus, on doit trouver soit \texttt{None} si la \textit{regexp} ne filtre pas l'intégralité de l'entrée ou bien une liste ordonnée de tuples qui donnent la valeur de ces groupes.

% vous n'avez rien à faire pour construire ces tuples, c'est l'exercice qui s'en occupe.

\end{exercise}

\begin{solution}[ID=7]
Un identificateur commence par une lettre ou un \textit{underscore} et peut être suivi par n'importe quel nombre de lettre, chiffre ou \textit{underscore}, ce qui se trouve être « \texttt{\textbackslash{w}} » si on ne se met pas en mode Unicode.

La solution est donc : \lstinline[basicstyle={\shellttfont}]{"[a-zA-Z_]\w*"}. Cette expression peut bien entendu également s'écrire en clair : \lstinline[basicstyle={\shellttfont}]{"[a-zA-Z_][a-zA-Z0-9_]*"}.

\begin{idleconsole}
	\begin{pyconsole}
def layout(match): # Fonction de mise en forme
    # le retour de re.match est soit "Vrai", soit "Faux"
    return "Faux" if match is None else "Vrai"

samples = ['a',' ','-','__','aa1','A1a','1Aa','-aa1']
regexp_pythonid = "[a-zA-Z_]\w*"
for sample in samples:
    match = re.match(regexp_pythonid, sample)
    print(f"{sample:>8} → {layout(match)}")

regexp_pythonid_bis = "[a-zA-Z_][a-zA-Z0-9_]*"
for sample in samples:
    match = re.match(regexp_pythonid_bis, sample)
    print(f"{sample:>8} → {layout(match)}")

	\end{pyconsole}
\end{idleconsole}
\end{solution}


\begin{solution}
L'exercice est fondé sur \texttt{re.match}, cela signifie que la correspondance est cherchée en début de chaîne, \emph{mais} il faut bien mettre \lstinline[basicstyle={\shellttfont}]{\Z} à la fin de la \textit{regexp}, sinon par ex. avec la sixième entrée le nom « Du Pré » sera reconnu partiellement comme « Du » au lieu d'être rejeté à cause de l'espace. Du coup bien penser à toujours définir les \textit{regexps} avec des \textit{raw-strings}.

Par ailleurs, il faut remarquer l'utilisation de \texttt{:?} à la fin de la \textit{regexp} pour signifier qu'on peut mettre ou non un deuxième séparateur « \texttt{:} ».

La solution donne : \lstinline[basicstyle={\shellttfont}]{r"\A(?P<prenom>[-\w]*):(?P<nom>[-\w]+):?\Z"}.

\begin{idleconsole}
	\begin{pyconsole}
agenda_strings = [
    "Daniel:Durand",
    "Jean:Dupont:",
    "Jean:Dupont::",
    ":Dupontel:",
    "Jean-Noël:Dupont-Nemours",
    "Charles-Henri:Du Pré",
    "Charles Henri:DuPré",
]
agenda = r"\A(?P<prenom>[-\w]*):(?P<nom>[-\w]+):?\Z"
for data in agenda_strings:
    match = re.match(agenda, data)
    print(f"{data:>24} → {layout(match)}")

	\end{pyconsole}
\end{idleconsole}
\end{solution}


\begin{solution}
La même remarque que dans l'exercice précédent s'applique concernant \lstinline[basicstyle={\shellttfont}]{\Z}. 
Par ailleurs, il faut bien mettre un \textit{backslash} le \texttt{+} devant les chiffres de l'international (\texttt{+33}) car sinon cela veut dire « un ou plusieurs ».

%Ainsi, la solution s'écrit : \lstinline[basicstyle={\shellttfont},language=python]{"(\+33|0)(?P<number>[0-9]{9})\Z"}
Ainsi, la solution s'écrit : \texttt{r"(\textbackslash{+}33|0)(?P<number>[0-9]\{9\})\textbackslash{Z}"}

\begin{idleconsole}
	\begin{pyconsole}
phone_strings = [
    "0123456789",
    "01234567890",
    "012345678",
    "1234567890",
    "+33123456789",
    "+3312345678",
    "+330123456789"]
phone = r"(\+33|0)(?P<number>[0-9]{9})\Z"
for data in phone_strings:
    match = re.match(phone, data)
    print(f"{data:>16} → {layout(match)}")

	\end{pyconsole}
\end{idleconsole}

\end{solution}

\begin{solution}
Une première solution est apportée par la construction pas-à-pas des différents groupes constitutifs de l'URL

\begin{idleconsole}
	\begin{pyconsole}
url_strings = """
http://www.google.com/a/b
HttPS://www.google.com:8080/a/b
http://user@www.google.com/a/b
FTP://username:hispass@www.google.com/
ssh://missing.ending.slash
gopher://unsupported.proto.col/
http:///missing/hostname/
""".split()

# En ignorant la casse on pourra ne mentionner 
# les noms de protocoles qu'en minuscules
i_flag = "(?i)"

# Pour élaborer la chaine (proto1|proto2|...)
protos_list = ['http', 'https', 'ftp', 'ssh', ]
protos = "(?P<proto>" + "|".join(protos_list) + ")"

# À l'intérieur de la zone 'user/password', la partie
# password est optionnelle - mais on ne veut pas le ':' dans
# le groupe 'password' - il nous faut deux groupes
password = r"(:(?P<password>[^:]+))?"

# La partie user-password elle-même est optionnelle
# on utilise ici un raw f-string avec le préfixe rf
# pour insérer la regexp <password> dans la regexp <user>
user = rf"((?P<user>\w+){password}@)?"

# Pour le hostname on accepte des lettres, chiffres, 
# underscore et '.' attention à backslaher . car sinon 
# ceci va matcher tout, y compris /
hostname = r"(?P<hostname>[\w\.]+)"

# Le port est optionnel
port = r"(:(?P<port>\d+))?"

# Après le premier slash
path = r"(?P<path>.*)"

# On assemble le tout
url = i_flag+protos+"://"+user+hostname+port+'/'+path

for data in url_strings:
    match = re.match(url, data)
    print(f"{data:>40} → {layout(match)}")

	\end{pyconsole}
\end{idleconsole}

Une seconde solution apportée par un participant au \textsc{Mooc} fait appel à \texttt{re.X} (cf. \url{https://docs.python.org/fr/3/library/re.html\#re.X}), ce qui donne une présentation beaucoup plus compacte.

\begin{idleconsole}
	\begin{pyconsole}
protos_list = ['http', 'https', 'ftp', 'ssh', ]

url_bis = rf"""(?x)                    # verbose mode
    (?i)                               # ignore case
    (?P<proto>{"|".join(protos_list)}) # http|https|...
    ://                                # separator
    ((?P<user>\w+){password}@)?        # optional user/pwd
    (?P<hostname>[\w\.]+)              # mandatory hostname
    (:(?P<port>\d+))?                  # optional port
    /(?P<path>.*)                      # mandatory path
"""

for data in url_strings:
    match = re.match(url_bis, data)
    print(f"{data:>40} → {layout(match)}")

	\end{pyconsole}
\end{idleconsole}

\end{solution}

%----------
\section[Notions de séquences et de listes]{Notions de séquences et de listes}
\label{sec:XI.2}

\subsection[Définition et manipulation]{Définition et manipulation}
\label{sub:XI.2.1}


\subsubsection[Séquences]{Séquences}
\label{subsub:XI.2.1.1}

En \textsc{Python}, les séquences regroupent un ensemble de types\sidenote{En pratique, les séquences concernent plus de types que ceux cités ici.} tels que les listes, les tuples, les chaînes de caractères et les octets. % : \texttt{list}, \texttt{tuple}, \texttt{str}, \texttt{bytes}.

\begin{marginvideo}
	[\label{vid:XI.4}Notion de séquence.]%
	\movie[width=\marginparwidth,showcontrols]%
		{\includegraphics[width=\marginparwidth]{./Images/Pictograms/film-strip-dark-electric-blue.png}}%
		{./Videos/Chapter11/vidXI-03-sequences-HD.mp4}%
	\launchvideo{./Videos/Chapter11/vidXI-03-sequences-HD.mp4}
\end{marginvideo}

Une séquence en \textsc{Python} est un ensemble fini et ordonné d'éléments indicés de $0$ à $n-1$ si l'on a $n$ éléments. Prenons un exemple et commençons avec une chaîne de caractères : \texttt{s = 'egg, bacon'}. Quel\-les sont les opérations communes aux objets « séquence » ?

On peut tout d'abord vouloir accéder à chaque élément de la séquence avec la notation entre crochet ; soit pour le premier élément \texttt{s[0]} et le dernier \texttt{s[9]}. Au passage, pour connaître le nombre d'éléments dans une séquence on utilise la fonction \textit{built-in} \texttt{len(s)}.


%!!!!! Coupure ici avec le chapitre précédent et exercices corrects !!!!!
%\vfill\pagebreak


Toutes les séquences supportent le test appartenance, opération très puissante en \textsc{Python}. Par exemple ici, est-que \texttt{'egg'} est dans \texttt{s}. Ou inversement est-ce \texttt{'egg'} n'est pas dans \texttt{s}. Ce test est relativement expressif et s'avère quasiment du langage naturel.

\begin{idleconsole}
	\begin{pyconsole}
s = 'egg, bacon'
s[0]
s[9]
len(s)
'egg' in s
'egg' not in s
	\end{pyconsole}
\end{idleconsole}

On peut ensuite faire de la concaténation de séquence en complémentant la chaîne par une nouvelle chaîne de caractères \texttt{', and beans'} pour obtenir un nouvel objet, ici de type chaîne de caractères. 

Il existe également des opérations qui permettent de retrouver certains éléments, comme \texttt{s.index(g)} et \texttt{s.count(g)} pour respectivement obtenir la première occurrence et le nombre d’occurrences de \texttt{'g'}. On peut en outre faire appel aux fonctions \textit{buit-in} \texttt{min(s)} et \texttt{max(s)} qui offre en retour le minimum et le maximum de la séquence, dans l'ordre lexicographique ici puisque la séquence est une chaîne de caractères.

Il existe une autre opération dite de \textit{shallow copy}\sidenote{Le concept de \textit{shallow copy} sera repris et explicité plus avant par la suite. Il peut y avoir des effets de bords lorsque l'objet considéré est un objet mutable et non immuable comme une chaîne de caractères.} --- littéralement « copie superficielle » --- qui permet de faire une copie d'un nombre donné de fois de la séquence. Pour simplifier, on considère ici comme séquence le caractère \texttt{'x'}. 

\begin{idleconsole}
	\begin{pyconsole}
s 
s + ', and beans'
s.index('g')
s.count('g')
min(s)
max(s)
'x'*30
	\end{pyconsole}
\end{idleconsole}

Une dernière opération abordée ici est celle de \textit{slicing} --- littéralement « taille, partage ». Elle permet de repérer et d'extraire les éléments d'une séquence selon le système d'indiçage. 

\sidegraphic[Indiçage d'une séquence.]{%
\begin{tikzpicture}[inner sep=0pt]
%\draw[step=0.25cm, style=help lines, line width=0.1pt] (-2.5,-1.0) grid (2.5,1.0);
%\draw[step=1cm, style=help lines, line width=0.8pt] (-2.5,-1.0) grid (2.5,1.0);
\node[font=\large] (l0) at (-2.0,0.0) {\strut\texttt{e}};
\node[font=\large, base right=2mm of l0] (l1) {\strut\texttt{g}};
\node[font=\large, base right=2mm of l1] (l2) {\strut\texttt{g}};
\node[font=\large, base right=2mm of l2] (l3) {\strut\texttt{,}};
\node[font=\large, base right=2mm of l3] (l4) {\strut\texttt{~}};
\node[font=\large, base right=2mm of l4] (l5) {\strut\texttt{b}};
\node[font=\large, base right=2mm of l5] (l6) {\strut\texttt{a}};
\node[font=\large, base right=2mm of l6] (l7) {\strut\texttt{c}};
\node[font=\large, base right=2mm of l7] (l8) {\strut\texttt{o}};
\node[font=\large, base right=2mm of l8] (l9) {\strut\texttt{n}};
\node[font=\footnotesize, below=1mm of l0] (n0) {\texttt{0}};
\node[font=\footnotesize, below=1mm of l1] (n1) {\texttt{1}};
\node[font=\footnotesize, below=1mm of l2] (n2) {\texttt{2}};
\node[font=\footnotesize, below=1mm of l3] (n3) {\texttt{3}};
\node[font=\footnotesize, below=1mm of l4] (n4) {\texttt{4}};
\node[font=\footnotesize, below=1mm of l5] (n5) {\texttt{5}};
\node[font=\footnotesize, below=1mm of l6] (n6) {\texttt{6}};
\node[font=\footnotesize, below=1mm of l7] (n7) {\texttt{7}};
\node[font=\footnotesize, below=1mm of l8] (n8) {\texttt{8}};
\node[font=\footnotesize, below=1mm of l9] (n9) {\texttt{9}};
\end{tikzpicture}}
Pour illustration, le point de départ est de reprendre la chaîne de caractères \texttt{'egg, bacon'} en indiçant ses éléments (cf. ci-contre). L'opération de \textit{slicing} se réalise en considérant une borne de gauche \emph{inclue} et une borne de droite dont l'élément est \emph{exclu}. Sa notation fait appel aux crochets et au glyphe de la double ponctuation, deux-points « \texttt{:} ».

Ainsi, \texttt{s[0:3]} retourne les trois premiers éléments de la chaîne de caractère, à savoir \texttt{'egg'} et \texttt{s[5:10]}, les éléments de 5 à 9 : \texttt{'bacon'}.
Si la borne de gauche n'est pas spécifiée (\texttt{s[:3]}), cela parcourt tous les éléments du début de la séquence à la borne droite \emph{exclue} (\texttt{'egg'} ici'). Inversement, si la borne de droite n'est pas spécifiée (\texttt{s[5:]}), cela parcourt tous les éléments de la borne de gauche \emph{inclue} jusqu'à le fin de la séquence (\texttt{'bacon'} ici). Si aucune des bornes n'est spécifiée (\texttt{s[:]}), cela retourne une copie dite \textit{shallow copy} de la séquence, mais pas l'objet de départ.

\begin{idleconsole}
	\begin{pyconsole}
s = 'egg, bacon'
s[0:3]
s[5:10]
s[:3]
s[5:]
s[:]
	\end{pyconsole}
\end{idleconsole}

Pour parcourir les éléments d'une séquence, on peut introduire la notion de \emph{pas}, par exemple un sur deux éléments si on donne un pas de deux : \texttt{s[0:10:2]}, soit ici la chaîne de caractère \texttt{'eg ao'}. Si on considère l'instruction \texttt{s[::2]}, soit parcourir la séquence du début à la fin par pas de deux, cela donne le même résultat.
Si maintenant on saisi \texttt{s[:8:3]}, l'extraction des éléments se fait du début de la séquence jusqu'au huitième élément exclu par pas de trois et fournit : \texttt{'e,a'}. \textit{A contrario}, \texttt{s[2:2:3]} parcourt la séquence du deuxième élément à la fin par pas de trois, ce qui conduit à \texttt{'gbo'}.

\begin{idleconsole}
	\begin{pyconsole}
s[0:10:2]
s[::2]
s[:8:3]
s[2::3]
	\end{pyconsole}
\end{idleconsole}

\sidegraphic[Indiçage négatif d'une séquence.]{%
\begin{tikzpicture}[inner sep=0pt]
%\draw[step=0.25cm, style=help lines, line width=0.1pt] (-2.5,-1.0) grid (2.5,1.0);
%\draw[step=1cm, style=help lines, line width=0.8pt] (-2.5,-1.0) grid (2.5,1.0);
\node[font=\large] (l0) at (-2.0,0.0) {\strut\texttt{e}};
\node[font=\large, base right=2.5mm of l0] (l1) {\strut\texttt{g}};
\node[font=\large, base right=2.5mm of l1] (l2) {\strut\texttt{g}};
\node[font=\large, base right=2.5mm of l2] (l3) {\strut\texttt{,}};
\node[font=\large, base right=2.5mm of l3] (l4) {\strut\texttt{~}};
\node[font=\large, base right=2.5mm of l4] (l5) {\strut\texttt{b}};
\node[font=\large, base right=2.5mm of l5] (l6) {\strut\texttt{a}};
\node[font=\large, base right=2.5mm of l6] (l7) {\strut\texttt{c}};
\node[font=\large, base right=2.5mm of l7] (l8) {\strut\texttt{o}};
\node[font=\large, base right=2.5mm of l8] (l9) {\strut\texttt{n}};
\node[font=\footnotesize, below=1mm of l0] (n0) {\texttt{0}};
\node[font=\footnotesize, below=1mm of l1] (n1) {\texttt{1}};
\node[font=\footnotesize, below=1mm of l2] (n2) {\texttt{2}};
\node[font=\footnotesize, below=1mm of l3] (n3) {\texttt{3}};
\node[font=\footnotesize, below=1mm of l4] (n4) {\texttt{4}};
\node[font=\footnotesize, below=1mm of l5] (n5) {\texttt{5}};
\node[font=\footnotesize, below=1mm of l6] (n6) {\texttt{6}};
\node[font=\footnotesize, below=1mm of l7] (n7) {\texttt{7}};
\node[font=\footnotesize, below=1mm of l8] (n8) {\texttt{8}};
\node[font=\footnotesize, below=1mm of l9] (n9) {\texttt{9}};
\node[font=\footnotesize, above=1mm of l0] (nn0) {\texttt{-10}};
\node[font=\footnotesize, above=1mm of l1] (nn1) {\texttt{-9}};
\node[font=\footnotesize, above=1mm of l2] (nn2) {\texttt{-8}};
\node[font=\footnotesize, above=1mm of l3] (nn3) {\texttt{-7}};
\node[font=\footnotesize, above=1mm of l4] (nn4) {\texttt{-6}};
\node[font=\footnotesize, above=1mm of l5] (nn5) {\texttt{-5}};
\node[font=\footnotesize, above=1mm of l6] (nn6) {\texttt{-4}};
\node[font=\footnotesize, above=1mm of l7] (nn7) {\texttt{-3}};
\node[font=\footnotesize, above=1mm of l8] (nn8) {\texttt{-2}};
\node[font=\footnotesize, above=1mm of l9] (nn9) {\texttt{-1}};
\end{tikzpicture}}%
Que se produit-il si les indices dépassent la taille la séquence ? L'instruction \texttt{s[100]} conduit assez logiquement à lever une exception et donne une erreur, mais si on introduit \texttt{s[5:100]} cela retourne \texttt{'bacon'} sans erreur. La raison est que \textsc{Python} prend tous les éléments couverts par le \textit{slice} et va chercher l'intersection avec les indices disponibles dans la chaîne de caractères considérée. Si on rentre l'instruction \texttt{s[100:200]}, le principe est le même : comme l'intersection est vide, cela retourne toujours un objet chaîne de caractère mais sans valeur.

\begin{idleconsole}
	\begin{pyconsole}
s[100]
s[5:100]
s[100:200]
	\end{pyconsole}
\end{idleconsole}

%\vspace{-\baselineskip}



Un autre aspect de l'opération de \textit{slicing} est relatif aux indices négatifs. Le comportement est toujours le même mais la numération commence par le dernier élément. Cela s'avère pratique lorsque l'on veut accéder directement à la fin d'une séquence dont on connaît les derniers éléments. Ainsi \texttt{s[-10:-7]} va retourner les éléments des indices \texttt{-10} inclus à \texttt{-7} exclu, soit \texttt{'egg'}. Même si l'indiçage est négatif, la séquence est toujours parcourue de la gauche vers la droite. De même que précédemment, \texttt{s[:-3]} parcours les éléments du début à l'indice \texttt{-3} exclu pour donner \texttt{'egg, ba'}.

Pour ce qui concerne les pas, un pas négatif fait parcourir la séquence de la fin au début. C'est un moyen relativement pratique pour inverser une séquence, à savoir \texttt{s[::-1]} apporte \texttt{'nocab ,gge'}. Cette fois \texttt{s[2:0:-1]} inverse le parcours mais pas l'indice donc sélectionne les éléments d'indices \texttt{2} inclus à \texttt{0} exclu soit \texttt{'gg'} et \texttt{s[2::-1]} retourne la séquence en allant de deux jusqu'au début soit \texttt{'gge'}.

\begin{idleconsole}
	\begin{pyconsole}
s[-10:-7]
s[:-3]
s[::-1]
s[2:0:-1]
s[2::-1]
	\end{pyconsole}
\end{idleconsole}


\subsubsection[Listes]{Listes}
\label{subsub:XI.2.1.2}

\begin{marginvideo}
	[\label{vid:XI.5}Notion de liste.]%
	\movie[width=\marginparwidth,showcontrols]%
		{\includegraphics[width=\marginparwidth]{./Images/Pictograms/film-strip-dark-electric-blue.png}}%
		{./Videos/Chapter11/vidXI-04-listes-HD.mp4}%
	\launchvideo{./Videos/Chapter11/vidXI-04-listes-HD.mp4}
\end{marginvideo}

\marginpar{\footnotesize\noindent \textsc{Bloc-note \cref{vid:XI.3}} (copier-coller)\\
\texttt{a = []}\\
\texttt{type(a)}\\
\texttt{i = 4}\\
\texttt{a = [i, 'spam', 3.2, True]}\\
\texttt{a}\\
\texttt{a[0]}\\
\texttt{a[0] = 6}\\
\texttt{a}\\
\texttt{a[0] = a[0] + 10}\\
\texttt{a}\\
\texttt{a[1:3]}\\
\texttt{a[1:3] = [1, 2, 3]}\\
\texttt{a}\\
\texttt{a[1:3] = []}\\
\texttt{a}\\
\texttt{del a[1:2]}\\
\texttt{a}\\
\texttt{dir(list)}\\
\texttt{list.append?}\\
\texttt{help(list.append)}\\
\texttt{a}\\
\texttt{a.append('18')}\\
\texttt{a}\\
\texttt{a.extend([1, 2, 3])}\\
\texttt{a}
\texttt{a = [1, 5, 3, 1, 7, 9, 2]}\\
\texttt{a.sort()}\\
\texttt{a}\\
\texttt{a = a.sort()}\\
\texttt{a}\\
\texttt{s = 'spam egg beans'}\\
\texttt{a = s.split()}\\
\texttt{a}\\
\texttt{a[0] = a[0].upper()}\\
\texttt{a}\\
\texttt{" ".join(a)}}

Une liste est une séquence d'objets hétérogènes. Ce concept est donc à la fois souple et puissant. Une liste peut contenir n'importe quels types d'objets, néanmoins il est important de comprendre que la liste ne stocke pas les objets en tant que tels mais les références vers ces objets. Par conséquent, la taille de l'objet liste est indépendante du type d'objets qui sont référencés.

Une liste est très malléable, on peut en augmenter la taille, la réduire, l'écarter au milieu pour rajouter des éléments à l'intérieur. C'est un objet dit \textit{mutable}, c'est-à-dire qu'on peut le modifier en place, autrement dit le changer à l'endroit où il est stocké. L'avantage de cette mutabilité est que l'on a pas besoin de faire une copie de l'objet pour le modifier, ce qui est très efficace au niveau mémoire.

Une liste est une séquence, par suite toutes les opérations sur les séquences sont applicables aux listes : test d'appartenance, concaténation, les fonctions \textit{built-in} \texttt{len}, \texttt{count}, \texttt{index}, etc.

Pour définir une liste, on utilise la notation entre crochets \texttt{a=[]} et \texttt{type(a)} retourne bien le type \texttt{list}. Une liste est composée d'éléments hétérogènes et même ceux référencé par une variable. On le vérifie en posant par exemple \texttt{i=4} puis \texttt{a=[i,'spam',3.2,True]}.

La liste est une séquence, on peut ainsi accéder à chacun de ses éléments, par exemple le premier \texttt{a[0]}. La liste étant un objet mutable, on peut également modifier un élément \texttt{a[0]=6}, voire directement faire une opération sur cet élément : \texttt{a[0]=a[0]+10}.

\begin{idleconsole}
\begin{pyconsole}
a = []
type(a)
i = 4
a = [i, 'spam', 3.2, True]
a
a[0]
a[0] = 6
a
a[0] = a[0] + 10
a
\end{pyconsole}
\end{idleconsole}

Là encore, comme la liste est une séquence, on peut appliquer les opérations de « \textit{slicing} », par exemple \texttt{a[1:3]} retourne \texttt{['spam',3.2]}.

On peut même faire des opérations d'affectation sur des \textit{slices}. En posant \texttt{a[1:3]=[1,2,3]} on obtient \texttt{[16,1,2,3,True]}. L'affectation va effectuer deux opérations indépendantes. La première (\texttt{a[1:3]}) enlève tous les éléments d'indices \texttt{1} inclus à \texttt{3} exclu. La seconde opération (\texttt{[1,2,3]}) est d'insérer les éléments donnés à la place de ceux effacés. C'est un moyen très facile de supprimer des éléments ; il suffit de les remplacer par une liste vide \texttt{a[1:3]=[]}. À noter que pour ce faire on peut aussi utiliser l'instruction \texttt{del a[1:2]}.

\begin{idleconsole}
\begin{pyconsole}
a[1:3]
a[1:3] = [1, 2, 3]
a
a[1:3] = []
a
del a[1:2]
a
\end{pyconsole}
\end{idleconsole}

Les opérations sur les listes sont nombreuses. Pour les obtenir, on peut utiliser la fonction \textit{built-in} \texttt{dir(list)} qui recense toutes les méthodes associées aux listes. Pour obtenir de l'aide sur une méthode particulière, il faut saisir \texttt{list.append?} avec l'interpréteur IPython et \texttt{help(list.append)} avec IDLE.

\begin{idleconsole*}
\begin{pyconsole}[][breaklines]
dir(list)
help(list.append)
\end{pyconsole}
\end{idleconsole*}

La méthode \texttt{append} rajoute un objet à la fin d'une liste comme suit \texttt{a.append('18')} pour la chaîne de caractère \texttt{18}. On peut également utiliser la méthode \texttt{extend} qui prend en entrée une séquence et va la rajouter à la fin de la liste : \texttt{a.extend([1, 2, 3])}. Le comportement est le même que faire un \texttt{append} sur chaque élément de la séquence.

La méthode \texttt{sort} trie une liste. Partant de \texttt{a=[1,5,3,1,7,9,2]}, on obtient \texttt{a=[1,1,2,3,5,7,9]}. Il faut bien noter que \texttt{sort} fonctionne en place, c'est-à-dire que la liste est triée sans copie temporaire et que la méthode ne retourne rien puisque la liste est triée en place.

\begin{idleconsole}
\begin{pyconsole}
a.append('18')
a
a.extend([1, 2, 3])
a
a = [1, 5, 3, 1, 7, 9, 2]
a.sort()
a
a = a.sort()
a
\end{pyconsole}
\end{idleconsole}

Une opération importante sur les listes est celle de passer une chaî\-ne de caractère à une liste et \textit{vice-versa}. C'est par exemple très utile dans la manipulation de fichiers traités avec \textsc{Python}.

On part d'une chaîne de caractère, par exemple issue de la lecture d'un fichier, \texttt{s='spam egg beans'} que l'on souhaite afficher en colonnes. On emploie d'abord la fonction \textit{built-in} \texttt{split} applicable aux chaînes de caractères \texttt{a=s.split()}. Le résultat est de découper la chaîne de caractère en utilisant l'espace comme séparateur. On obtient une liste qui contient trois éléments : \texttt{'spam'}, \texttt{'egg'} et \texttt{'beans'}.

La liste étant mutable, on peut tout à fait lui appliquer un traitement. Ici on souhaite mettre le premier élément en capitales : \texttt{a[0]=a[0].upper()}. Ensuite on peut de nouveau transcrire la liste en chaîne de caractères : \texttt{" ".join(a)}. La syntaxe signifie que l'on définit d'abord le séparateur (ici une espace) puis on juxtapose les éléments pour retrouver une chaîne de caractère avec le premier mot en lettres capitales.

\begin{idleconsole}
\begin{pyconsole}
s = 'spam egg beans'
a = s.split()
a
a[0] = a[0].upper()
a
" ".join(a)
\end{pyconsole}
\end{idleconsole}


\subsection[Compléments et application]{Compléments et application}
\label{sub:XI.2.2}


\subsubsection[Séquences, listes et \textit{slicing}]{Séquences, listes et \textit{slicing}}
\label{subsub:XI.2.2.1}

Cette section reprend et complète ce qui a pu être abordé sur les \textit{slices} en \cref{subsub:XI.2.1.1}. L'illustration est conduite sur la chaîne de caractères constituée des lettres de l'alphabet, mais est applicable aux listes aussi bien qu'aux tuples.

Une \textit{slice} désigne toute une plage d'éléments d'une séquence. Les débutants ont parfois du mal avec les bornes. Il faut se souvenir que :
\begin{itemize}
\item les indices commencent comme toujours à zéro ;
\item le premier indice de début est inclus ;
\item le second indice de fin est exclu ;
\item on obtient en tout fin-debut items dans le résultat.
\end{itemize}
\sidegraphic[\textup{Slicing} sur une séquence.]{%
\begin{tikzpicture}[inner sep=0pt]
%\draw[step=0.25cm, style=help lines, line width=0.1pt] (-2.5,-1.0) grid (2.5,1.0);
%\draw[step=1cm, style=help lines, line width=0.8pt] (-2.5,-1.0) grid (2.5,1.0);
\node[font=\large] (l0) at (-2.0,0.0) {\strut\texttt{a}};
\node[font=\large, base right=2mm of l0] (l1) {\strut\texttt{b}};
\node[font=\large, base right=2mm of l1] (l2) {\strut\texttt{c}};
\node[font=\large, base right=2mm of l2] (l3) {\strut\texttt{d}};
\node[font=\large, base right=2mm of l3] (l4) {\strut\texttt{e}};
\node[font=\large, base right=2mm of l4] (l5) {\strut\texttt{f}};
\node[font=\large, base right=2mm of l5] (l6) {\strut\texttt{g}};
\node[font=\large, base right=2mm of l6] (l7) {\strut\texttt{h}};
\node[font=\large, base right=2mm of l7] (l8) {\strut\texttt{i}};
\node[font=\large, base right=2mm of l8] (l9) {\strut\texttt{j}};
\node[font=\footnotesize, above=1mm of l0] (n0) {\texttt{0}};
\node[font=\footnotesize, above=1mm of l1] (n1) {\texttt{1}};
\node[font=\footnotesize, above=1mm of l2] (n2) {\texttt{2}};
\node[font=\footnotesize, above=1mm of l3] (n3) {\texttt{3}};
\node[font=\footnotesize, above=1mm of l4] (n4) {\texttt{4}};
\node[font=\footnotesize, above=1mm of l5] (n5) {\texttt{5}};
\node[font=\footnotesize, above=1mm of l6] (n6) {\texttt{6}};
\node[font=\footnotesize, above=1mm of l7] (n7) {\texttt{7}};
\node[font=\footnotesize, above=1mm of l8] (n8) {\texttt{8}};
\node[font=\footnotesize, above=1mm of l9] (n9) {\texttt{9}};
%---
\node[font=\small, below=1mm of l0] (m0) {\strut\texttt{[x}};
\node[font=\small, below=1mm of l1] (m1) {\strut\texttt{x}};
\node[font=\small, below=1mm of l2] (m2) {\strut\texttt{x[}};
\node[font=\small, below=1mm of l3] (m3) {\strut\texttt{~}};
\node[font=\small, below=1mm of l4] (m4) {\strut\texttt{~}};
\node[font=\small, below=1mm of l5] (m5) {\strut\texttt{~}};
\node[font=\small, below=1mm of l6] (m6) {\strut\texttt{~}};
%---
\node[font=\small, below=1mm of m0] (p0) {\strut\texttt{~}};
\node[font=\small, below=1mm of m1] (p1) {\strut\texttt{~}};
\node[font=\small, below=1mm of m2] (p2) {\strut\texttt{~}};
\node[font=\small, below=1mm of m3] (p3) {\strut\texttt{[x}};
\node[font=\small, below=1mm of m4] (p4) {\strut\texttt{x}};
\node[font=\small, below=1mm of m5] (p5) {\strut\texttt{x}};
\node[font=\small, below=1mm of m6] (p6) {\strut\texttt{x[}};
%---
\node[font=\small, below=1mm of p0] {\strut\texttt{[x}};
\node[font=\small, below=1mm of p1] {\strut\texttt{x}};
\node[font=\small, below=1mm of p2] {\strut\texttt{x}};
\node[font=\small, below=1mm of p3] {\strut\texttt{x}};
\node[font=\small, below=1mm of p4] {\strut\texttt{x}};
\node[font=\small, below=1mm of p5] {\strut\texttt{x}};
\node[font=\small, below=1mm of p6] {\strut\texttt{x[}};
%---
\end{tikzpicture}}
Ainsi, pour \texttt{chaine[2:6]}, le résultat contient 6-2 = 4 éléments. Pour aider à mémoriser les conventions de début et de fin, on peut se rappeler qu'on doit pouvoir facilement juxtaposer deux \textit{slices} qui ont une borne commune : \texttt{chaine[a:b] + chaine[b:c] == chaine[a:c]}

\begin{idleconsole}
\begin{pyconsole}
chaine = "abcdefghijklmnopqrstuvwxyz"
print(chaine)
chaine[2:6]
chaine[0:3] + chaine[3:7] == chaine[0:7]
\end{pyconsole}
\end{idleconsole}

On peut omettre une borne dans une \textit{slice} sur un objet. Trois cas de figure se présentent alors :
\begin{enumerate}
\item si on omet la première borne, la \textit{slice} commence au début ;
\item c'est pareil avec la fin de l'objet pour la seconde borne ;
\item en ne spécifiant aucune borne, on fait une copie de l'objet.
\end{enumerate}

On peut également utiliser des indices négatifs pour compter à partir de la fin de l'objet.

\begin{idleconsole}
\begin{pyconsole}
chaine[:6]
chaine[24:]
chaine[:]
chaine[3:-3]
chaine[-3:]
\end{pyconsole}
\end{idleconsole}

Il est possible de préciser un pas, de façon à ne choisir par exemple, dans la plage donnée, qu'un élément sur deux : \texttt{chaine[3:-3:2]}. Le pas est défini après un deuxième deux-points « \texttt{:} » ; ici on choisit un caractère sur deux dans l'intervalle \texttt{[3:-3]}. Comme on le devine, le troisième élément de la \textit{slice}, ici \texttt{2}, détermine le pas. On ne retient donc, dans la chaîne \texttt{defghi}... que \texttt{d}, puis \texttt{f} et ainsi de suite.

On peut préciser du coup la borne de fin (ici \texttt{-3}) avec un peu de liberté, puisqu'ici on obtiendrait un résultat identique avec \texttt{-4}.

Il est encore envisageable de spécifier un pas négatif. Dans ce cas, de manière un peu contre-intuitive, il faut préciser un début (le premier indice de la \textit{slice}) qui soit plus à droite que la fin (le second indice).

Pour prendre un exemple, comme l'élément d'indice \texttt{-3}, c'est-à-dire \texttt{x}, est plus à droite que l'élément d'indice \texttt{3}, c'est-à-dire \texttt{d}. Évidemment si on ne précise pas le pas (qui revient à choisir un pas égal à 1), on obtiendrait une liste vide. Si maintenant on précise un pas négatif, on obtient cette fois : \texttt{chaine[-3:3:-2]}.

\begin{idleconsole}
\begin{pyconsole}
chaine[3:-3:2]
chaine[3:-4:2]
chaine[-3:3]
chaine[-3:3:-2]
\end{pyconsole}
\end{idleconsole}

À nouveau, il faut se souvenir que ces mécanismes fonctionnent avec de nombreux autres types que les chaînes de caractères. En voici deux exemples --- sur les listes et en utilisant la bibliothèque \textsc{NumPy} --- qui anticipent tous les deux sur la suite, mais qui illustrent les vastes possibilités qui sont offertes avec les \textit{slices}.

\begin{idleconsole}
\begin{pyconsole}
liste = [1, 2, 4, 8, 16, 32]
liste
liste[-1:1:-2]
liste[2:4] = [10, 20, 30]
liste
\end{pyconsole}
\end{idleconsole}

La \cref{fig:XI.4} expose une représentation imagée de ce qui se passe lorsqu'on exécute cette dernière ligne de code \texttt{liste[2:4]=[10,20,30]} ; cela revient en quelque sorte à remplacer la \textit{slice} à gauche de l'affectation (ici \texttt{liste[2:4]}) par la liste à droite de l'affectation (ici \texttt{[10,20,30]}) --- ce qui a pour effet de modifier la longueur de la liste.


\vspace{8pt}

\begin{jazzfigure}
\centering
\begin{tikzpicture}
%\draw[step=0.25cm, style=help lines, line width=0.1pt] (-5.0,-3.0) grid (5.0,3.0);
%\draw[step=1cm, style=help lines, line width=0.8pt] (-5.0,-3.0) grid (5.0,3.0);
\begin{scope}[xshift=2cm]
\node[fill=maincolor, font=\small, minimum width=6mm] (a1) at (-2.5,0.5) {\texttt{1}};
\node[fill=maincolor, font=\small, minimum width=6mm] (a2) at (-1.5,0.5) {\texttt{2}};
\node[fill=maincolor, font=\small, minimum width=6mm] (a3) at (-0.5,0.5) {\texttt{4}};
\node[fill=maincolor, font=\small, minimum width=6mm] (a4) at (0.5,0.5) {\texttt{8}};
\node[fill=maincolor, font=\small, minimum width=6mm] (a5) at (1.5,0.5) {\texttt{16}};
\node[fill=maincolor, font=\small, minimum width=6mm] (a6) at (2.5,0.5) {\texttt{32}};
%---
\node[fill=maincolor!40, font=\small, minimum width=6mm, text=black!50] (b1) at (-2.5,-0.5) {\texttt{1}};
\node[fill=maincolor!40, font=\small, minimum width=6mm, text=black!50] (b2) at (-1.5,-0.5) {\texttt{2}};
\node[fill=maincolor, font=\small, minimum width=6mm] (b3) at (-0.5,-0.5) {\texttt{4}};
\node[fill=maincolor, font=\small, minimum width=6mm] (b4) at (0.5,-0.5) {\texttt{8}};
\node[fill=maincolor!40, font=\small, minimum width=6mm, text=black!50] (b5) at (1.5,-0.5) {\texttt{16}};
\node[fill=maincolor!40, font=\small, minimum width=6mm, text=black!50] (b6) at (2.5,-0.5) {\texttt{32}};
%---
\node[fill=maincolor, font=\small, minimum width=6mm] (c1) at (-2.5,-1.5) {\texttt{1}};
\node[fill=maincolor, font=\small, minimum width=6mm] (c2) at (-1.5,-1.5) {\texttt{2}};
%\node[fill=maincolor, font=\small, minimum width=6mm] (c3) at (-0.5,-1.5) {\texttt{4}};
%\node[fill=maincolor, font=\small, minimum width=6mm] (c4) at (0.5,-1.5) {\texttt{8}};
\node[fill=maincolor, font=\small, minimum width=6mm] (c5) at (1.5,-1.5) {\texttt{16}};
\node[fill=maincolor, font=\small, minimum width=6mm] (c6) at (2.5,-1.5) {\texttt{32}};
%---
\node[fill=maincolor, font=\small, minimum width=6mm] (d1) at (-1.0,-2.5) {\texttt{10}};
\node[fill=maincolor, font=\small, minimum width=6mm] (d2) at (-0.0,-2.5) {\texttt{20}};
\node[fill=maincolor, font=\small, minimum width=6mm] (d3) at (1.0,-2.5) {\texttt{30}};
%---
\draw[thick] (a1.east) -- (a2.west);
\draw[thick] (a2.east) -- (a3.west);
\draw[thick] (a3.east) -- (a4.west);
\draw[thick] (a4.east) -- (a5.west);
\draw[thick] (a5.east) -- (a6.west);
%---
\draw[thick, color=maincolor!40] (b1.east) -- (b2.west);
\draw[thick, color=maincolor!40] (b2.east) -- (b3.west);
\draw[thick, color=black] (b3.east) -- (b4.west);
\draw[thick, color=maincolor!40] (b4.east) -- (b5.west);
\draw[thick, color=maincolor!40] (b5.east) -- (b6.west);
%---
\draw[thick] (c1.east) -- (c2.west);
%\draw[thick] (c2.east) -- (c3.west);
%\draw[thick] (c3.east) -- (c4.west);
%\draw[thick] (c4.east) -- (c5.west);
\draw[thick] (c5.east) -- (c6.west);
%---
\draw[thick] (d1.east) -- (d2.west);
\draw[thick] (d2.east) -- (d3.west);
%---
\draw[-latex, line width=0.6pt] 
	(d1.west) to[curve through={(-1.5,-2.25) .. (-0.75,-1.75)}] (-1.0,-1.5);
\draw[-latex, line width=0.6pt] 
	(d3.east) to[curve through={(1.5,-2.25) .. (0.75,-1.75)}] (1.0,-1.5);
%---
\node[font=\Large, inner sep=0pt] (v1) at (-1.0,-0.5) {\texttt{[}};
\node[font=\Large, inner sep=0pt] (v2) at (1.07,-0.5) {\texttt{[}};
\node[font=\Large, inner sep=0pt, text=maincolor!60] (v3) at (-1.0,-1.5) {\texttt{[}};
\node[font=\Large, inner sep=0pt, text=maincolor!60] (v4) at (1.07,-1.5) {\texttt{[}};
\end{scope}
\node[anchor=east, font=\small] at (-1.25,0.5) {\strut\texttt{liste}};
\node[anchor=east, font=\small] at (-1.25,-0.5) {\strut\texttt{liste[2:4]}};
\node[anchor=east, font=\small] at (-1.25,-1.5) {\strut\texttt{liste[2:4]=[10,20,30]}};
\end{tikzpicture}
\vspace{2pt}
\caption{\label{fig:XI.4}Insertion d'éléments dans une liste avec une \textup{slice}.}
\end{jazzfigure}

%\vspace{6pt}

La bibliothèque \textsc{NumPy} permet de manipuler des tableaux ou des matrices de manière optimale. En anticipant (beaucoup) sur son usage (visité en détail par la suite), on présente ici un aperçu du potentiel des \textit{slices} sur des objets \textsc{NumPy}.

\begin{idleconsole*}
\begin{pyconsole}
import numpy as np # Importation de la bibliothèque

un_cinq = np.array([1, 2, 3, 4, 5]) # Construction d'un tableau ligne
un_cinq
array = 10 * un_cinq[:, np.newaxis] + un_cinq # On le combine avec lui-même en utilisant une slice 
array                                         # un peu magique pour former un tableau carré 5x5
centre = array[1:4, 1:4] # Sur ce tableau de taille 5x5, on peut aussi faire 
centre                   # du slicing et extraire le sous-tableau 3x3 au centre
coins = array[::4, ::4] # On peut bien sûr également utiliser un pas
coins
tete_en_bas = array[::-1,:] # Ou bien retourner complètement dans une direction
tete_en_bas
\end{pyconsole}
\end{idleconsole*}

\subsubsection[Méthodes spécifiques aux listes]{Méthodes spécifiques aux listes}
\label{subsub:XI.2.2.2}

Pour se remémorer les méthodes applicables aux listes, il faut saisir \texttt{help(list)} dans un interpréteur \textsc{Python}. Dans un premier temps on peut ignorer les méthodes qui débutent et se terminent par un double \textit{underscore}, restent alors les méthodes comprises entre \texttt{append} et \texttt{sort} : \texttt{clear}, \texttt{copy}, \texttt{count}, \texttt{extend}, \texttt{index}, \texttt{insert}, \texttt{pop}, \texttt{remove}, \texttt{reverse}. 

Certaines de ces méthodes ont été vues en \cref{subsub:XI.2.1.1} sur les séquences, c'est le cas notamment de \texttt{count} et \texttt{index}. Il s'agit à présent de faire état des autres méthodes.


\begin{idleconsole*}
\begin{pyconsole}[][breaklines]
help(list)
\end{pyconsole}
\end{idleconsole*}

Pour commencer, donnons-nous une liste témoin \texttt{liste=[0,1,2,3]} à laquelle appliquer le différentes méthodes :
\vspace{-1pt}% WHY?
\begin{itemize}
\item la méthode \texttt{append} ajoute un élément à la fin d'une liste :
\item la méthode \texttt{extend} réalise la même opération, mais avec \emph{tous les éléments} de la liste qu'on lui passe en argument.
\end{itemize}

\begin{idleconsole}
\begin{pyconsole}
liste = [0, 1, 2, 3]
print('liste :', liste)
liste.append('ap')
print('liste', liste)
liste2 = ['ex1', 'ex2']
liste.extend(liste2)
print('liste', liste)
\end{pyconsole}
\end{idleconsole}

Ces deux méthodes \texttt{append} et \texttt{extend} sont donc assez voisines. 

%\vspace{-2pt}

Avant de voir d'autres méthodes de \texttt{list}, prenons le temps de comparer leur comportement avec l'addition de liste « \texttt{+} ». L'élément clé ici  est que la liste est un objet \emph{mutable}. Ainsi, \texttt{append} et \texttt{extend} \emph{modifient} la liste sur laquelle elles travaillent, alors que l'addition \emph{crée un nouvel objet}. C'est pour cette raison que :
\vspace{-1pt}
\begin{itemize}
\item l'addition est disponible sur tous les types séquences --- on peut toujours réaliser l'addition puisqu'on crée un nouvel objet pour stocker le résultat de l'addition ;
\item mais \texttt{append} et \texttt{extend} ne sont par exemple pas disponibles sur les chaînes de caractères, qui sont immuables.
\end{itemize}

\vspace{-1pt}

\begin{idleconsole*}
\begin{pyconsole}[][breaklines]
a1 = list(range(3)) # Pour créer une liste avec les n premiers entiers, on utilise
print(a1)           # la fonction built-in range(), que l'on convertit en liste
a2 = list(range(10, 13))
print(a2)
a3 = a1 + a2    # Le fait d'utiliser "+" crée une nouvelle liste
print('a1', a1) # si bien que maintenant on a trois objets différents
print('a2', a2) # Comme on le voit, après une addition, les deux termes de l'addition sont inchangés.
print('a3', a3)
\end{pyconsole}
\end{idleconsole*}

\vspace{-1pt}

On reprend l'inventaire des méthodes de \texttt{list} avec la méthode \texttt{insert}. Comme son nom le suggère, elle permet d'insérer un élément à une certaine position (comme toujours les indices commencent à zéro). On peut remarquer qu'un résultat analogue peut être obtenu avec une affectation de \textit{slice} ; par exemple pour une insertion au rang 5 ici.

\vspace{-1pt}

\begin{idleconsole}
\begin{pyconsole}
print('liste :', liste) # Rappel du contenu de "liste"
liste.insert(2, '1 bis') # Insertion à l'index 2
print('liste', liste)
liste[5:5] = ['3 bis']
print('liste', liste)
\end{pyconsole}
\end{idleconsole}

\vspace{-1pt}

Quant à elle, la méthode \texttt{remove} détruit la \emph{première occurrence} d'un objet dans la liste.

\vspace{-1pt}

\begin{idleconsole}
\begin{pyconsole}
liste.remove(3)
print('liste :', liste)
\end{pyconsole}
\end{idleconsole}

\vspace{-1pt}

La méthode \texttt{pop} prend en argument un indice ; elle permet d'extraire l'élément ayant cet indice. En un seul appel on obtient la valeur de l'élément et on l'enlève de la liste. Si l'indice n'est pas précisé, c'est le dernier élément de la liste qui est visé.

\vspace{-1pt}

\begin{idleconsole}
\begin{pyconsole}
popped = liste.pop(0)
print('popped :', popped, ' ; liste :', liste)
popped = liste.pop()
print('popped :', popped, ' ; liste :', liste)
\end{pyconsole}
\end{idleconsole}

Enfin, la méthode \texttt{reverse},\caution[t]<firstcolor>{%
\href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{Documentation officielle sur les listes}}{Pour en savoir plus}
 comme son nom l'indique, renverse la liste ; le premier élément devient le dernier. On peut alors remarquer ici que le résultat se rapproche de ce qu'on peut obtenir avec une opération de \textit{slicing} comme suit. \emph{À la différence toutefois} qu'avec le \textit{slicing} c'est une copie de la liste initiale qui est retournée, la liste de départ quant à elle n'est pas modifiée.

\begin{idleconsole}
\begin{pyconsole}
liste.reverse()
print('liste :', liste)
liste2 = liste[::-1]
print('liste2', liste2)
\end{pyconsole}
\end{idleconsole}

\subsubsection[Mutabilité et immuabilité des objets]{Mutabilité et immuabilité des objets}
\label{subsub:XI.2.2.3}

Voici ci-dessous un fragment de code qui illustre le caractère immuable des chaînes de caractères. Le scénario est très simple, on crée deux variables \texttt{s1} et \texttt{s2} vers le même objet \texttt{'abc'}, puis on fait une opération \texttt{+=} sur la variable \texttt{s1}.

Comme l'objet est une chaîne, il est donc immuable, on ne peut pas modifier l'objet directement ; pour obtenir l'effet recherché (à savoir que \texttt{s1} s'allonge de \texttt{'def'}), \textsc{Python} crée un deuxième objet.

\begin{idleconsole}
\begin{pyconsole}
s1 = 'abc' # Deux variables vers le même objet
s2 = s1
s1 += 'def' # On essaie de modifier l'objet
print(s1)
print(s2)
\end{pyconsole}
\end{idleconsole}

Les listes sont des objets mutables. Voici par contraste ce qu'on obtient pour le même scénario mais qui, cette fois, utilise des listes.

\begin{idleconsole}
\begin{pyconsole}
liste1 = ['a', 'b', 'c'] # Deux variables vers le même objet
liste2 = liste1
liste1 += ['d', 'e', 'f'] # On modifie l'objet
print(liste1)
print(liste2)
\end{pyconsole}
\end{idleconsole}

\begin{linewidthnote}
Ce comportement n'est pas propre à l'usage de l'opérateur \texttt{+=}, les objets mutables et immuables ont par essence un comportement différent, il est très important d'avoir ceci présent à l'esprit.
\end{linewidthnote}

\subsubsection[Tris de listes]{Tris de listes}
\label{subsub:XI.2.2.4}

\textsc{Python} fournit une méthode standard pour trier une liste, qui s'appelle, sans grande surprise, \texttt{sort}.

\begin{idleconsole}
\begin{pyconsole}
liste = [8, 7, 4, 3, 2, 9, 1, 5, 6]
print('Avant le tri : ', liste)
liste.sort()
print('Après le tri : ', liste)
\end{pyconsole}
\end{idleconsole}

On retrouve ici, avec l'instruction \texttt{liste.sort()} un cas d'appel de méthode (ici \texttt{sort}) sur un objet (ici \texttt{liste}).
La première chose à remarquer est que la liste d'entrée a été modifiée --- on dit « en place » ou « par effet de bord ».
On aurait pu imaginer que la liste d'entrée soit restée inchangée et que la méthode de tri renvoie une copie triée de la liste, ce n'est pas le choix qui a été fait en \textsc{Python} ; cela permet d'économiser des allocations mémoire autant que possible et d'accélérer sensiblement le tri.

En revanche, si on a besoin de faire le tri sur une copie de liste, la fonction \texttt{sorted} permet de le réaliser.

\begin{idleconsole}
\begin{pyconsole}
liste1 = [3, 2, 9, 1]
liste2 = sorted(liste1)
print('Après le tri de la copie : ', liste2)
\end{pyconsole}
\end{idleconsole}

Revenons à la méthode \texttt{sort} et aux \textit{tris en place}. Par défaut la liste est triée par ordre croissant, si au contraire on souhaite l'ordre décroissant, on peut faire comme suit.

\begin{idleconsole}
\begin{pyconsole}
liste = [8, 7, 4, 3, 2, 9, 1, 5, 6]
print('Avant le tri :', liste)
liste.sort(reverse=True)
print('Après le tri décroissant : ', liste)
\end{pyconsole}
\end{idleconsole}

On a pas encore vu à quoi correspond cette formule \texttt{reverse=True} dans l'appel à la méthode --- ceci est approfondi dans le chapitre sur les appels de fonction --- mais dans l'immédiat on peut utiliser cette technique telle quelle.

Cette technique fonctionne très bien sur tous les types numériques à l'exception des complexes\sidenote{En guise d'exercice, pourquoi ?}, ainsi que sur les chaînes de caractères. 

Pour les chaînes de caractères, comme on s'y attend, il s'agit cette fois d'un \emph{tri lexicographique}, dérivé de l'ordre sur les caractères. Autrement dit, c'est l'ordre du dictionnaire. Il faut souligner toutefois, pour les personnes n'ayant jamais été exposées à l'informatique, que cet ordre, quoique déterministe, est arbitraire en dehors des lettres de l'alphabet.
Lorsque les chaînes contiennent des espaces ou autres ponctuations, le résultat du tri peut paraître surprenant.

\begin{idleconsole*}
\begin{pyconsole}
liste = ['spam', 'egg', 'bacon', 'beef']
liste.sort()
print('Après le tri : ', liste)

'a' < 'z' # Deux caractères minuscules se comparent selon l'ordre lexicographique

'Z' < 'a' # Si l'un est en minuscule et l'autre en majuscule, ce n'est plus le cas

liste = ['abc', 'Zoo'] # Conséquence de 'Z' < 'a'
liste.sort()
print(liste)

liste = [' zoo', 'ane'] # Attention ici la première chaîne commence par une espace
liste.sort()            # et le caractère 'Espace' est plus petit
print(liste)            # que tous les autres caractères imprimables

\end{pyconsole}
\end{idleconsole*}



%----------
\section[\texorpdfstring{Introduction aux conditionnelles,\newline itérations et fonctions}{Introduction aux conditionnelles, itérations et fonctions}]{Conditionnelles, itérations et fonctions}
\label{sec:XI.3}

Jusqu'ici les notions importantes abordées sont les concepts d'objet, de variable, de typage dynamique, mais aussi les types centraux comme les chaînes de caractères ou les listes et encore les opérations sur les séquences. Toutefois, cela ne suffit pas pour écrire de vrais programmes. Il faut en effet également maîtriser les tests, les boucles et les fonctions \qnameref{chap:VI} \cref{subsub:VI.1.1.3}.


\subsection[Test {\normalfont\texttt{if-else}}]{Test {\normalfont\texttt{if-else}}}
\label{sub:XI.3.1}

\subsubsection[Utilisation]{Utilisation}
\label{subsub:XI.3.1.1}

\begin{marginvideo}
	[\label{vid:XI.6}Conditionnelle.]%
	\movie[width=\marginparwidth,showcontrols]%
		{\includegraphics[width=\marginparwidth]{./Images/Pictograms/film-strip-dark-electric-blue.png}}%
		{./Videos/Chapter11/vidXI-05-if-introduction-HD.mp4}%
	\launchvideo{./Videos/Chapter11/vidXI-05-if-introduction-HD.mp4}
\end{marginvideo}

Le test \texttt{if-else} permet de faire de l'exécution conditionnelle, c'est-à-dire qu'un morceau de code va s'effectuer selon que le résultat d'un test est vrai ou faux.

On peut ainsi tester toute expression qui retourne un booléen com\-me (voir récapitulation partielle au \cref{tab:XI.2}) les relations d'ordre, l'égalité, la différence ou les tests d'appartenance.

\begin{margintable}
\caption{\label{tab:XI.2}Expressions applicables aux conditionnelles.}
\small
%\centering
\renewcommand*{\arraystretch}{1.6}
\rowcolors{2}{tableLineOne}{tableLineTwo}
\begin{tabularx}{\linewidth}{l>{\ttfamily}Y}
\rowcolor{secondcolor}
%\multicolumn{2}{c}{\Gape[6pt]{\textcolor{white}{\normalfont\textbf{}}}} \\
%\rowcolor{firstcolor}
\multicolumn{1}{c}{\Gape[6pt]{\textcolor{white}{\textbf{Relation}}}} &
\multicolumn{1}{c}{\Gape[6pt]{\textcolor{white}{\textbf{Expression}}}} \\
Supérieur & a > b \\
Supérieur ou égal & a >= b \\
Inférieur & a < b \\
Inférieur ou égal & a <= b \\
Égalité & a == b \\
Différence & a != b \\
Appartenance & a in s\\
Absence & a not in s \\
\end{tabularx}%
\end{margintable}

Supposons que l'on veuille afficher un message pour toute note supérieure à 10/20. On commence par définir une variable \texttt{note}. La syntaxe de l'instruction \texttt{if} est alors comme suit.

\begin{idleconsole}
\begin{pyconsole}
note = 8
if note > 10:
    print('Reçu')
    print('Bravo')
else:
    print('Recalé')

\end{pyconsole}
\end{idleconsole}

On peut remarquer que l'on a systématiquement un deux-points « \texttt{:} » avant chaque bloc d'instruction. Un bloc d'instruction est une ensemble d'instructions qui sont toutes indentées, par convention, de quatre espaces vers la droite.

Ainsi, si le test est vrai on entre dans le premier bloc d'instruction, s'il est faux on se retrouve dans le bloc d'instruction de la clause \texttt{else}, également repérée par un deux-points.

\subsubsection[Blocs d'instruction et syntaxe]{Blocs d'instruction et syntaxe}
\label{subsub:XI.3.1.2}


\textsc{Python} est conçu autour du concept de bloc d'instruction. Dans d'autres langages, il n'y a pas cette notion et les blocs d’instructions sont explicitement délimités par des séparateurs comme les accolades.

Reprenons le même test, mais avec une syntaxe « à la \textsc{Java} ». Toutes les instructions finissent par un point-virgule pour déterminer leur fin et les blocs d'instructions sont eux délimités par des accolades. 

\begin{code*}{java}
note = 8;
if note > 10 {
  System.out.print("Reçu");
  System.out.print("Bravo !");
  }
else
  { System.out.print("Recalé"); }
\end{code*}

Ce principe s'avère un problème connu en programmation puisque pour être capable de savoir où placer les accolades, on définit ce que l'on appelle des conventions de codage. La convention n'a aucun impact sur l'exécution du code, mais elle est adoptée pour faciliter l'écriture et la lecture du code. 

Or, ces conventions de codage font partie d'écoles de programmation et certaines personnes préfèrent par exemple mettre les accolades en début et fin de ligne ou aligner les accolades sur les instructions. En fait, lire un code écrit avec une convention qui n'est pas la sienne rend extrêmement difficile l'interprétation ou la lecture de ce code.

En \textsc{Python}, ce problème n'existe pas puisque la convention de codage fait partie de la syntaxe. Si on ne respecte pas la convention, le code ne s'exécute pas en indiquant une erreur de syntaxe. L'avantage est qu'il n'y a qu'une seule manière de présenter le code.

Seul est conservé dans la syntaxe un deux-point « \texttt{:} » précédant les blocs d'instructions. Il est issu de tests utilisateurs qui ont démontrés que cela rendait plus aisée la lecture du code.

Le fait que \textsc{Python} utilise l'indentation comme base de sa syntaxe n'a presque que des avantages, cela donne un code : toujours écrit de la même manière, bien présenté, facile à lire et à écrire. Il existe cependant un seul inconvénient, que cette syntaxe fondée sur l'indentation supporte mal le copier-coller. Dans ce cas de figure, la recommandation est naturellement de bien vérifier ce point lorsque l'on récupère des bouts de codes sur Internet ou depuis d'autres programmes.

Cette convention de codage qui décale les blocs d'instructions de quatre espaces vers la droite a tendance à créer des lignes un petit peu longues. Il est préconiser ici de ne pas dépasser 79 caractères par ligne de code. Même si aujourd'hui les écrans sont grands, l'idée est de pouvoir juxtaposer plusieurs éditeurs de texte. Quoi qu'il en soit, il est plus facile de lire des lignes courtes.

Par ailleurs, \textsc{Python} permet de retourner sans peine à la ligne car tous ce qui est entre parenthèses, entre crochets ou entre accolades supportent le retour chariot sans générer des problèmes dans la syntaxe de \textsc{Python}. Cela autorise une présentation du code bien lisible lorsque par exemple, on a une grande liste (crochets) ou un nombre important d'expressions (parenthèses).


\subsection[Factorisation de code]{Factorisation de code}
\label{sub:XI.3.2}

Un principe fondateur de la programmation est ce qu'on appelle la \emph{factorisation de code}. C'est ce qui permet de ne pas réécrire plusieurs fois un code qui fait la même chose. L'intérêt est évidemment de faciliter la maintenance et surtout la qualité du code. Sont abordées ici les notions de boucle \texttt{for} et les fonctions qui sont deux techniques traditionnelles de factorisation.

\subsubsection[Boucle {\normalfont\texttt{for}}]{Boucle {\normalfont\texttt{for}}}
\label{subsub:XI.3.2.1}

\begin{marginvideo}
	[\label{vid:XI.7}Boucle \texttt{for}.]%
	\movie[width=\marginparwidth,showcontrols]%
		{\includegraphics[width=\marginparwidth]{./Images/Pictograms/film-strip-dark-electric-blue.png}}%
		{./Videos/Chapter11/vidXI-06-boucle-for-fonctions-HD.mp4}%
	\launchvideo{./Videos/Chapter11/vidXI-06-boucle-for-fonctions-HD.mp4}
\end{marginvideo}

Supposons que l'on veuille afficher à l'écran les carrés des nombres allant de 0 à 9. On peut écrire \texttt{print(1**2)}, \texttt{print(2**2)}, \texttt{print(3**2)} et ainsi de suite... En continuant de cette manière, on se rend compte rapidement que c'est une tâche très fastidieuse. On peut alors automatiser cette tâche au moyen d'une boucle \texttt{for}.

%\mintinline{python}{print(1**2)}, \mintinline{python}{print(2**2)}, \mintinline{python}{print(3**2)}

\marginpar{\footnotesize\noindent \textsc{Bloc-note \cref{vid:XI.7}} (copier-coller)\\
\texttt{print(1**2)}\\
\texttt{print(2**2)}\\
\texttt{print(3**2)}\\
\texttt{for i in range(10):}\\
\hspace*{4ex}\texttt{print(i**2)}\\
\texttt{for i in ['a', 3.5, True]:}\\
\hspace*{4ex}\texttt{print(i)}\\
\texttt{a = [1, 2, 5, 8, 9]}\\
\texttt{for i in a:}\\
\hspace*{4ex}\texttt{print(i**2)}\\
\texttt{b = [3.6, 18, 12, 25]}\\
\texttt{for i in b:}\\
\hspace*{4ex}\texttt{print(i**2)}\\
\texttt{def carre(a):}\\
\hspace*{4ex}\texttt{for i in a:}\\
\hspace*{8ex}\texttt{print(i**2)}\\
\texttt{carre(a)}\\
\texttt{carre(b)}\\
\texttt{def carre(a):}\\
\hspace*{4ex}\texttt{L = []}\\
\hspace*{4ex}\texttt{for i in a:}\\
\hspace*{8ex}\texttt{L.append(i**2)}\\
\hspace*{4ex}\texttt{return L}\\
\texttt{carre(b)}\\
\texttt{b = carre(b)}\\
\texttt{b}
}

La syntaxe d'une boucle \texttt{for} est donnée ci-dessous où \texttt{i} est une variable et \texttt{range(10)} est objet qui permet de parcourir tous les entiers allant de \texttt{0} à \texttt{9}. Avec un deux-point, la fin de ligne annonce un bloc d'instruction ---  ici \texttt{print(i**2)} ---, qui débute à la ligne suivante décalée de quatre espaces vers la droite. La variable \texttt{i} référence chacun des entiers à chaque tour de boucle et \texttt{print(i**2)} affiche le carré de \texttt{i}.

\begin{idleconsole}
\begin{pyconsole}
for i in range(10):
    print(i**2)

\end{pyconsole}
\end{idleconsole}

On peut mettre n'importe quelle séquence voire itérable\sidenote{Concept abordé par la suite.} dans une boucle \texttt{for}. On peut par exemple considérer une liste contenant une chaîne caractère, un \textit{float} et un booléen puis afficher simplement la variable \texttt{i} d'itération pour avoir chaque élément de la liste.

\begin{idleconsole}
\begin{pyconsole}
for i in ['a', 3.5, True]:
    print(i)

\end{pyconsole}
\end{idleconsole}

\subsubsection[Fonctions]{Fonctions}
\label{subsub:XI.3.2.2}

Reprenons l'exemple de l'affichage du carré et supposons que l'on ait deux listes \texttt{a=[1,2,5,8,9]} et \texttt{b=[3.6,18,12,25]}. Pour avoir leur carrés respectifs, on peut reprendre la démarche précédente avec deux boucles \texttt{for} distinctes. Là encore, c'est un peu fastidieux de réécrire deux fois la même boucle \texttt{for}. Une manière de factoriser ce code est d'utiliser ce que l'on appelle une fonction.

\overparagraph{Définition}

Une fonction est un morceau de code que l'on peut rappeler n'importe quand. Comme pour un test et une boucle, une fonction débute par le mot-clef \texttt{def}, suivi de son nom --- ici \texttt{carre} --- et des arguments d'entrée, pour terminer la ligne par deux-points indiquant un bloc d'instruction à suivre. Une fois définie, la fonction peut être appelé n'importe où dans le code.

\begin{idleconsole}
\begin{pyconsole}
a = [1, 2, 5, 8, 9]
for i in a:
    print(i**2)

b = [3.6, 18, 12, 25]
for i in b:
    print(i**2)

def carre(x):
    for i in x:
        print(i**2)

carre(a)
carre(b)

\end{pyconsole}
\end{idleconsole}

\vspace{1pt}

\overparagraph{Retour de fonction}

En pratique, avec une fonction on fait rarement des affichages avec des \texttt{print()} ; en revanche l'objectif est plutôt d'obtenir un retour. L'instruction \texttt{return} permet le retour d'un traitement par une fonction. Dans notre exemple, il s'agit de la liste du carré des entiers qui se définit par une liste initiale vide à laquelle on ajoute à chaque tour de boucle le carré de la variable d'itération, avant de renvoyer la liste complète.

\begin{idleconsole}
\begin{pyconsole}
def carre(a):
    L = []
    for i in a:
        L.append(i**2)
    return L

carre(b)
b = carre(b)
b
\end{pyconsole}
\end{idleconsole}


\subsection[Compléments et application]{Compléments et application}
\label{sub:XI.3.3}


\subsubsection[Bonnes pratiques]{Bonnes pratiques}
\label{subsub:XI.3.3.1}

\overparagraph{Indentation en Python}

La pratique la plus courante est d'utiliser systématiquement une indentation de quatre espaces.

\begin{idleconsole}
\begin{pyconsole}
if 'g' in 'egg': # Convention d'indentation à quatre espaces
    print('OUI')
else:
    print('NON')

\end{pyconsole}
\end{idleconsole}

Pour écrire plusieurs tests imbriqués, il est donc nécessaire d'avoir une indentation de huit espaces.

\begin{idleconsole}
\begin{pyconsole}
entree = 'spam'
if 'a' in entree:
    if 'b' in entree: # Imbrication à huit espaces
        cas11 = True
        print('a et b')
    else:
        cas12 = True
        print('a mais pas b')
else:
    if 'b' in entree:
        cas21 = True
        print('b mais pas a')
    else:
        cas22 = True
        print('ni a ni b')

\end{pyconsole}
\end{idleconsole}

Cette façon d'organiser le code peut paraître très étrange, notamment aux gens habitués à un autre langage de programmation, puisqu'en général les syntaxes des langages sont conçues de manière à être insensibles aux espaces et à la présentation.

Cependant, après s'y être familiarisé, cette pratique est très agréable. Par exemple, une fois qu'on a écrit la dernière ligne du code, on n'a pas à réfléchir à refermer le bon nombre d'accolades ou de « \texttt{end} ».
Par ailleurs, comme pour tous les langages, les éditeurs connaissent cette syntaxe et aident à respecter la règle des quatre caractères d'espace.

Il faut par contre apporter quelques détails sur un problème fréquemment rencontré avec du code partagé entre plusieurs personnes, quand celles-ci utilisent des environnement différents.

\begin{linewidthnote}
Pour faire court, ce problème est susceptible d'apparaître dès qu'on utilise des \emph{tabulations}, plutôt que des espaces, pour implémenter les indentations. Aussi, le message à retenir ici est de \emph{ne jamais utiliser de tabulations} dans un code \textsc{Python}. Tout bon éditeur devrait faire cela par défaut.
\end{linewidthnote}

En version longue, il existe un code ASCII pour un caractère qui s'appelle Tabulation (alias \keys{Ctrl+I}, qu'on note aussi \lstinline[basicstyle={\small\shellttfont}]{^}I) ; l'interprétation de ce caractère n'étant pas clairement spécifiée, il arrive qu'on se retrouve dans une situation comme la suivante.

Un utilisateur code avec l'éditeur \textsc{vim} sous lequel il est possible de mettre des tabulations dans son code et de choisir la valeur de ces tabulations. Aussi il va dans les préférences, choisit Tabulation=4 et écrit un programme qu'il voit comme ceci :

\begin{codebox}{python}
if 'a' in entree:
    if 'b' in entree:
        cas11 = True
        print('a et b')
    else:
        cas12 = True
        print('a mais pas b')
\end{codebox}

Sauf qu'en fait, il y a mis un mélange de tabulations et d'espaces, le fichier se présente comme suit (avec \lstinline[basicstyle={\small\shellttfont}]{^}I pour tabulation).

\begin{codebox}{python}
if 'a' in entree:
^Iif 'b' in entree:
^I^Icas11 = True
    ^Iprint('a et b')
^Ielse:
^I^Icas12 = True
    ^Iprint('a mais pas b')
\end{codebox}

On peut remarquer le mélange de tabulations et d'espaces dans les deux lignes avec \texttt{print}. L'utilisateur envoie alors son code à un collègue qui utilise \textsc{emacs}. Dans son environnement, \textsc{emacs} affiche une tabulation comme 8 caractères. Du coup son collègue « voit » le code suivant :

\begin{codebox}{python}
if 'a' in entree:
        if 'b' in entree:
                cas11 = True
            print('a et b')
        else:
                cas12 = True
            print('a mais pas b')
\end{codebox}

Bref, c'est la confusion la plus totale. Aussi répétons-le, \emph{n'utilisez jamais de tabulations } dans un code \textsc{Python}.

Cela ne veut pas dire qu'il ne faut pas utiliser la touche \keys{Tab} avec un éditeur --- au contraire, c'est une touche très pratique ---, mais il faut bien faire la différence entre le fait d'appuyer sur la touche \keys{Tab} et le fait que le fichier sauvé sur disque contient effectivement un caractère de tabulation. Les bons éditeurs proposent très certainement une option permettant de faire les remplacements idoines pour ne pas écrire de tabulation dans les fichiers, tout en permettant d'indenter le code correctement avec la touche \keys{Tab}.

À cet égard, signalons enfin que \textsc{Python} 3 est plus restrictif que \textsc{Python} 2 et interdit de mélanger des espaces et des tabulations sur une même ligne. Ce qui n'enlève rien à la recommandation faite.

\overparagraph{Explication de la règle d'indentation}

Pour les curieux, \textsc{Python} n'impose pas que les indentations soient de quatre caractères. Aussi il est possible de rencontrer un code qui ne respecte pas cette convention et il faut, pour être tout à fait précis sur ce que \textsc{Python} accepte ou non, expliciter ce qui est réellement requis par \textsc{Python}.

La règle utilisée pour analyser un code, c'est que toutes les instructions d'un un même bloc soient présentées avec le même niveau d'indentation. Si deux lignes successives --- modulo les blocs imbriqués --- ont la même indentation, elles sont dans le même bloc.
Bien que légal, le code à suivre n'est pas recommandé.

\begin{idleconsole}
\begin{pyconsole}
# Code accepté mais pas du tout recommandé
if 'a' in 'pas du tout recommande':
  succes = True
  print('OUI')
else:
      print('NON')

\end{pyconsole}
\end{idleconsole}

En effet, les deux blocs (après \texttt{if} et après \texttt{else}) sont des blocs distincts, ils sont libres d'utiliser deux indentations différentes (ici 2 et 6). \textit{A contrario}, la construction ci-dessous n'est pas légale.

\begin{idleconsole}
\begin{pyconsole}
# Ceci est incorrect et rejeté par Python
if 'a' in entree:
    if 'b' in entree:
        cas11 = True
        print('a et b')
      else:
        cas12 = True
        print('a mais pas b')

\end{pyconsole}
\end{idleconsole}

Ici les deux lignes \texttt{if} et \texttt{else} font logiquement partie du même bloc, elles doivent donc avoir la même indentation. Avec cette présentation le lecteur \textsc{Python} émet une erreur et ne peut pas interpréter le code.

\overparagraph{Présentation de code}

On trouve dans la \href{https://legacy.python.org/dev/peps/pep-0008/}{PEP-008} (en anglais) les conventions de codage qui s'appliquent à toute la bibliothèque standard et qui sont certainement un bon point de départ pour aider à trouver le style de présentation qui convient à chacun. Les sections plus particulièrement conseillées sont : l'\href{https://legacy.python.org/dev/peps/pep-0008/\#code-lay-out}{indentation} ; les \href{https://legacy.python.org/dev/peps/pep-0008/\#whitespace-in-expressions-and-statements}{espaces} ; les \href{https://legacy.python.org/dev/peps/pep-0008/\#comments}{commentaires}.
%\setlength{\columnsep}{8pt}
%\begin{multicols}{3}
%\begin{itemize}\jazzitem
%\item l'\href{https://legacy.python.org/dev/peps/pep-0008/\#code-lay-out}{indentation} ;
%\item les \href{https://legacy.python.org/dev/peps/pep-0008/\#whitespace-in-expressions-and-statements}{espaces} ;
%\item les \href{https://legacy.python.org/dev/peps/pep-0008/\#comments}{commentaires}.
%\end{itemize}
%\end{multicols}

\paragraph*{Illustration par l'exemple}
On peut prendre en exemple le code du module \texttt{pprint} (comme \textit{PrettyPrint}) de la bibliothèque standard (\directory{/lib/python3.8/\texttt{pprint.py}}) qui permet d'imprimer des données de manière élaborée.

\begin{codebox}{python}
from modtools import show_module_html
import pprint
show_module_html(pprint)
\end{codebox}

La fonction du module\caution[t]<firstcolor>{%
Bien qu'ayant installé le module \textsc{modtools}, il n'a pas été possible de faire appel à la fonction \texttt{show\_module\_html}. Cela fonctionne dans le \textsc{Mooc} initial avec \textit{notebook}. Aussi le code source est directement consultable dans le répertoire de la bibliothèque standard \directory{/lib/python3.8/\texttt{pprint.py}} pour Ubuntu MATE.}{Note de la rédaction}
 --- le \textit{pretty printing} --- est évidemment accessoire ici, mais on peut y voir illustré :
\begin{itemize}
\item le \textit{docstring} pour le module aux lignes 11 à 35 ;
\item les indentations, comme déjà mentionné à quatre espaces et sans aucune tabulation ;
\item l'utilisation des espaces, autour des affectations et opérateurs, des définitions de fonction, des appels de fonctions, etc. ;
\item les lignes de largeur « raisonnable » (79 caractères) ;
\item la coupure les lignes pour respecter cette limite en largeur.
\end{itemize}

\paragraph*{Espaces}
Comme on peut le voir dans \texttt{pprint.py}, les règles principales concernant les espaces sont les suivantes.
\begin{itemize}\jazzitem
\item S'agissant des affectations et opérateurs, on saisira \texttt{x = y + z}, non pas \cancel{\texttt{x=y+z}}, ni \cancel{\texttt{x~=~y+z}}, ni encore \cancel{\texttt{x=y~+~z}}. L'idée étant d'aérer de manière homogène pour faciliter la lecture.
\item  Pour les déclarations de fonction on entrera \texttt{def foo(x, y, z):} et non pas avec un espace en trop avant la parenthèse ouvrante \cancel{\texttt{def foo (x, y, z):}}, ni surtout sans espace entre les arguments \cancel{\texttt{def foo(x,y,z):}}
\end{itemize}

Il est important de noter qu'il s'agit ici de \emph{règles d'usage} et non pas de règles syntaxiques; tous les exemples barrés ci-dessus sont en fait \emph{syntaxiquement corrects}, l'interpréteur les accepterait sans souci ; mais ces règles sont très largement adoptées et obligatoires pour intégrer du code dans la bibliothèque standard.

\paragraph*{Coupures de ligne}
On va à présent zoomer dans le module \texttt{pprint.py} pour voir quelques exemples de coupure de ligne. Par con\-traste avec ce qui précède, il s'agit ici surtout de règles syntaxiques, qui peuvent rendre un code non valide si elles ne sont pas respectées.

La fonction \texttt{pprint} (ligne 47) est une commodité (qui crée une instance de \texttt{PrettyPrinter}, sur lequel on envoie la méthode \texttt{pprint}). On voit là qu'il n'est pas nécessaire d'insérer un \textit{backslash} (\texttt{\textbackslash}) à la fin des lignes 50 et 51, car il y a une parenthèse ouvrante qui n'est pas fermée à ce stade.

De manière générale, lorsqu'une parenthèse ouvrante « \texttt{(} » --- \textit{idem} avec les crochets « \texttt{[} » et accolades « \texttt{\{} » --- n'est pas fermée sur la même ligne, l'interpréteur suppose qu'elle sera fermée plus loin et n'impose pas de \textit{backslash}.
On peut donc écrire :

\begin{codebox}{python}
valeurs = [ 
   1,
   2,
   3,
   5,
   7,
]
x = un_nom_de_fonction_tres_tres_long(
       argument1, argument2,
       argument3, argument4,
    )
\end{codebox}

À titre de rappel, signalons aussi les chaînes de caractères à base de \texttt{"""} ou \texttt{'''} qui permettent elles aussi d'utiliser plusieurs lignes consécutives sans \textit{backslash}.

\begin{codebox}{python}
texte = """Les sanglots longs
Des violons
De l'automne"""
\end{codebox}

Néanmoins, il existe des cas où le \textit{backslash} est nécessaire. On peut l'illustrer par la ligne 536 du fichier \texttt{pprint.py}.

Dans tous les cas où une instruction est répartie sur plusieurs lignes, c'est naturellement l'indentation de la première ligne qui est significative afin de savoir à quel bloc rattacher cette instruction.

Bien noter enfin qu'on peut toujours mettre un \textit{backslash} même lorsque ce n'est pas nécessaire, mais cette pratique est en règle générale évitée car les \textit{backslash} nuisent à la lisibilité.

Il existe plusieurs outils liés à la PEP0008, pour vérifier si un code est conforme, ou même le modifier pour qu'il le devienne.

Cela donne un excellent prétexte pour parler un peu du site \url{https://pypi.python.org}, qui est la plateforme qui distribue les logiciels disponibles via l'outil \texttt{pip3} --- acronyme récursif pour \textit{Pip Installs Python} ou \textit{PIP Installs Packages}. On peut notamment signaler ici :
\begin{itemize}
\item l'outil \texttt{pep8} pour vérifier ;
\item l'outil \texttt{autopep8} pour modifier automatiquement un code et le rendre conforme aux conventions d'usage.
\end{itemize}

Dans un autre registre, on peut se reporter à ce \href{https://docs.python.org/3/faq/design.html\#why-are-colons-required-for-the-if-while-def-class-statements}{lien} afin de savoir pourquoi on a choisi un délimiteur (le caractère deux-points « \texttt{:} ») pour terminer les instructions comme \texttt{if}, \texttt{for} et \texttt{def}.

\overparagraph{Instruction {\normalfont\ttfamily pass}}

En \textsc{Python} les blocs de code sont définis par leur indentation. Cette convention a une limitation lorsqu'on essaie de définir un bloc vide. Voyons par exemple comment on définirait en C une fonction qui ne fait absolument rien :

\begin{codebox}{c}
/* une fonction C qui ne fait rien */
void foo() {}
\end{codebox}

Comme en \textsc{Python} on n'a pas d'accolade pour délimiter les blocs de code, il existe une instruction \texttt{pass}, qui ne fait rien. À l'aide de cette instruction on peut à présent définir une fonction vide comme ci-dessous

\begin{codebox}{python}
# une fonction Python qui ne fait rien
def foo():
    pass
\end{codebox}

Pour prendre un second exemple un peu plus pratique et pour anticiper un peu sur l'instruction \texttt{while} abordéplus loin dans le cours, voici un exemple d'une boucle vide, c'est à dire sans corps, qui permet de «~dépiler » dans une liste jusqu'à l'obtention d'une certaine valeur. On voit qu'ici encore l'instruction \texttt{pass} a toute son utilité.

\begin{idleconsole}
\begin{pyconsole}
liste = list(range(10))
print('Avant : ', liste)
while liste.pop() != 5:
    pass

print('Après : ', liste)
\end{pyconsole}
\end{idleconsole}

Dans les exemples à suivre on utilise une condition fausse. Imaginons qu'on parte d'un code hypothétique qui fasse ceci :

\begin{idleconsole}
\begin{pyconsole}
condition = False # Utilisation d'une condition fausse
if condition: # Version initiale
    print("non")
else:
    print("bingo")

\end{pyconsole}
\end{idleconsole}

Supposons maintenant que l'on veuille modifier ce code pour simplement supprimer l'impression de « \texttt{non} ». La syntaxe du langage ne \emph{permet pas} de simplement commenter le premier \texttt{print}.

\begin{idleconsole}
\begin{pyconsole}
# En commentant le premier print la syntaxe devient incorrecte
if condition: 
#    print("non")
else:
    print("bingo")

\end{pyconsole}
\end{idleconsole}

Évidemment ceci pourrait être récrit autrement en inversant la con\-dition, mais parfois on s'efforce de limiter au maximum l'impact d'une modification sur le code. Dans ce genre de situation on préférera écrire plutôt le code suivant.

\begin{idleconsole}
\begin{pyconsole}
# On peut s'en sortir en ajoutant une instruction pass
if condition: 
#    print("non")
    pass
else:
    print("bingo")

\end{pyconsole}
\end{idleconsole}

Enfin, on peut également employer l'instruction \texttt{pass} pour définir une classe vide comme suit.

\begin{codebox}{python}
class Foo:
    pass
    
foo = Foo()
\end{codebox}

\subsubsection[Fonctions et valeur de retour]{Fonctions et valeur de retour}
\label{subsub:XI.3.3.2}

Une procédure est une fonction qui se contente de dérouler des instructions. Voici un exemple d'une telle fonction :

\begin{idleconsole}
\begin{pyconsole}
def affiche_carre(n): # Définition
    print("Le carré de", n, "vaut", n*n)

affiche_carre(12) # Utilisation
\end{pyconsole}
\end{idleconsole}

Mais en fait, dans ce cas, il serait beaucoup plus commode de définir une fonction qui retourne le carré d'un nombre, afin de pouvoir écrire quelque chose comme \texttt{surface = carre(15)}, quitte à imprimer cette valeur ensuite si nécessaire. Jusqu'ici nous avons fait beaucoup appel à \texttt{print}, mais dans la pratique, imprimer n'est pas un but en soi.

Voici comment on pourrait écrire une fonction \texttt{carre} qui \emph{retourne} (on dit aussi \emph{renvoie}) le carré de son argument.

\begin{idleconsole}
\begin{pyconsole}
def carre(n):
    return n*n

if carre(8) <= 100:
    print('Petit appartement')

\end{pyconsole}
\end{idleconsole}

La sémantique\sidenote{Mot savant pour « comportement ».} de l'instruction \texttt{return} est assez simple. La fonction qui est en cours d'exécution s'achève immédiatement et l'objet cité dans l'instruction \texttt{return} est retourné à l'appelant, qui peut employer cette valeur comme n'importe quelle expression.

Le terme même de fonction, si on se rappelle ses souvenirs de mathématiques, suggère qu'on calcule un résultat à partir de valeurs d'entrée. Dans la pratique, il est assez rare qu'on définisse une fonction qui ne retourne rien.

En fait toutes les fonctions renvoient quelque chose. Lorsque le programmeur n'a pas prévu d'instruction \texttt{return}, \textsc{Python} retourne un objet spécial, baptisé \texttt{None}. Voilà ce qu'on obtient si on essaie d'afficher le retour de la fonction \texttt{affiche\_carre} qui ne retourne rien.

\begin{idleconsole*}
\begin{pyconsole}
retour = affiche_carre(15) # Premier appel provoquant l'impression d'une ligne
print('retour =', retour)  # Retour de la fonction
\end{pyconsole}
\end{idleconsole*}

L'objet \texttt{None} est un singleton prédéfini par \textsc{Python}, un peu comme \texttt{True} et \texttt{False}. Ce n'est pas par contre une valeur booléenne.

Pour illustrer l'utilisation de \texttt{return} sur un exemple plus utile, considérons le code suivant.

\begin{idleconsole*}
\begin{pyconsole}
def premier(n):
    """
    Retourne un booléen selon que n est premier ou non.
    Retourne None pour les entrées négatives ou nulles.
    """
    if n <= 0: # retourne None pour les entrées non valides
        return
    # Traitement du cas singulier (NB: elif est un raccourci pour else if)
    # C'est utile pour éviter une indentation excessive
    elif n == 1:
        return False
    # Recherche d'un diviseur dans [2..n-1],
    # bien sûr on pourrait s'arrêter à la racine carrée de n mais ce n'est pas notre sujet
    else:
        for i in range(2, n):
            if n % i == 0:
                return False # On a trouvé un diviseur, on peut sortir de la fonction
    return True # À ce stade, le nombre est bien premier

\end{pyconsole}
\end{idleconsole*}

Cette fonction teste si un entier est premier ou non ; il s'agit naturellement d'une version d'école, il existe d'autres méthodes beaucoup plus adaptées à cette tâche. On peut toutefois vérifier que cette version est fonctionnelle pour de petits entiers comme suit. On rappelle que le chiffre « \texttt{1} » n'est pas considéré comme un nombre premier.

\begin{idleconsole}
\begin{pyconsole}
for test in [-2, 1, 2, 4, 19, 35]:
    print(f"premier({test:2d}) = {premier(test)}")

\end{pyconsole}
\end{idleconsole}

Pour les besoins de la discussion, on a choisi de retourner \texttt{None} pour les entiers négatifs ou nuls, une manière comme une autre de signaler que la valeur en entrée n'est pas valide. Ceci n'est pas forcément une bonne pratique, mais elle permet ici d'illustrer que dans le cas où on ne mentionne pas de valeur de retour, \textsc{Python} retourne \texttt{None}.

Comme on peut s'en convaincre en instrumentant le code --- ce que l'on peut faire à titre d'exercice en ajoutant des fonctions \texttt{print} --- dans le cas d'un nombre qui n'est pas premier, la boucle \texttt{for} ne va pas jusqu'à son terme.
On aurait pu tirer profit de cette propriété pour écrire la fonction de manière légèrement différente, à l'instar de ce qui suit.

\begin{idleconsole*}
\begin{pyconsole}
def premier_sans_else(n):
    """
    Retourne un booléen selon que n est premier ou non
    Retourne None pour les entrées négatives ou nulles
    """
    if n <= 0: # Retourne None pour les entrées non valides
        return
    if n == 1: # Traitement du cas singulier
        return False
    # Par rapport à la première version, on a supprimé la clause else: qui est inutile
    for i in range(2, n):
        if n % i == 0:
            return False # On a trouve un diviseur
    return True # À ce stade c'est que le nombre est bien premier

\end{pyconsole}
\end{idleconsole*}


C'est une question de style et de goût. En tout cas, les deux versions sont tout à fait équivalentes.

\begin{idleconsole}
\begin{pyconsole}
for test in [-2, 2, 4, 19, 35]:
    print(f"Pour n = {test:2d} : premier → {premier(test)}\n"
          f"    premier_sans_else → {premier_sans_else(test)}\n")

\end{pyconsole}
\end{idleconsole}

\paragraph*{Digression sur les chaînes}
On peut remarquer dans ce dernier morceau de code, en regardant bien le paramètre de \texttt{print}, qu'on peut accoler deux chaînes de caractères (ici deux f-strings) sans même les ajouter ; un petit détail pour éviter d'alourdir le code.

\begin{idleconsole}
\begin{pyconsole}
# Quand deux chaînes apparaissent immédiatement
# l'une après l'autre sans opérateur, elles sont concaténées
"abc" "def"
\end{pyconsole}
\end{idleconsole}

\subsubsection[Exercices]{Exercices}
\label{subsub:XI.3.3.3}

\begin{exercise}[title=Notes des élèves, level=basic]
On demande d'écrire une fonction qui prend deux arguments :
\begin{jazzitemize}
\item une chaîne de caractères qui désigne le prénom d'un élève ;
\item un entier qui indique la note obtenue.
\end{jazzitemize}
Elle devra retourner une chaîne de caractères selon que la note est :
\begin{multicols}{3}
\begin{jazzitemize}
\item 0 ≤ note < 10
\item 10 ≤ note < 16
\item 16 ≤ note ≤ 20
\end{jazzitemize}
\end{multicols}
\end{exercise}

\begin{exercise}[title={Séquences et {\itshape slicing}}, level=basic]
Commençons par créer une chaîne de caractères. Ne pas s'inquiéter en cas d'incompréhension du code d'initialisation\sidenote{Pour les plus curieux, l'instruction \texttt{import} permet de charger dans un programme une boîte à outils que l'on appelle un module. \textsc{Python} vient avec de nombreux modules qui forment la bibliothèque standard. Le plus difficile avec les modules de la bibliothèque standard est de savoir qu'ils existent. En effet, il y en a un grand nombre et bien souvent il existe un module pour réaliser la tâche souhaitée. Ici en particulier nous utilisons le module \textsc{string}.} utilisé ci-dessous. 

%Pour les plus curieux, l'instruction \texttt{import} permet de charger dans un programme une boîte à outils que l'on appelle un module. \textsc{Python} vient avec de nombreux modules qui forment la bibliothèque standard. Le plus difficile avec les modules de la bibliothèque standard est de savoir qu'ils existent. En effet, il y en a un grand nombre et bien souvent il existe un module pour réaliser la tâche souhaitée. Ici en particulier nous utilisons le module \textsc{string}.

\begin{idleconsole}
\begin{pyconsole}
import string # Constante définie dans le module string
chaine = string.ascii_lowercase
print(chaine) # Voici sa valeur
\end{pyconsole}
\end{idleconsole}

Pour chacune des sous-chaînes ci-après, écrire une expression de \textit{slicing} sur \texttt{chaine} qui renvoie la sous-chaîne. La cellule de code doit retourner \texttt{True}. Par exemple, pour obtenir « \texttt{def} » : \texttt{chaine[3:6] == "def"}.
\begin{enumerate}
\item Écrire une \textit{slice} pour obtenir « \texttt{vwx} » (ne pas hésiter à utiliser les indices négatifs) :\texttt{ chaine[ <code> ] == "vwx"}.
\item Écrire une \textit{slice} pour obtenir « \texttt{wxyz} » (avec une seule constante) : \texttt{chaine[ <code> ] == "wxyz"}.
\item Écrire une \textit{slice} pour obtenir « \texttt{dfhjlnprtvxz} » (avec deux constantes) : \texttt{chaine[ <vcode> ] == "dfhjlnprtvxz"}.
\item Écrire une \textit{slice} pour obtenir « \texttt{xurolifc} » (avec deux constantes) : \texttt{chaine[ <code> ] == "xurolifc"}.
\end{enumerate}

En cas de difficulté pour répondre à ces questions, consulter \cref{subsub:XI.2.2.1}.
\end{exercise}

\begin{exercise}[title={Séquences et longueur}, level=intermediate]
On donne une chaîne composite dont on sait qu'elle a été calculée à partir de deux chaînes \texttt{inconnue} et \texttt{connue} comme ceci : \texttt{composite = connue + inconnue + connue}
On fournit également la chaîne \texttt{connue}. Si par exemple, \texttt{connue = '0bf1'} et \texttt{composite = '0bf1a9730e150bf1'} alors \texttt{inconnue = 'a9730e15'}.

L'exercice consiste à écrire une fonction qui retourne la valeur de \texttt{inconnue} à partir de celles de \texttt{composite} et \texttt{connue}. On peut admettre que \texttt{connue} n'est pas vide, c'est-à-dire qu'elle contient au moins un caractère.
On peut utiliser du \textit{slicing} et la fonction \texttt{len()}, qui retourne la longueur d'une chaîne : \texttt{len('abcd')=4}.
\end{exercise}

\begin{exercise}[title={Listes}, level=basic]
Écrire une fonction \texttt{laccess} qui a en argument une liste et qui renvoie :
\begin{itemize}
\item \texttt{None} si la liste est vide ;
\item sinon le dernier élément de la liste si elle est de taille paire ;
\item et sinon l'élément du milieu.
\vspace{-.25\baselineskip}
\end{itemize}
\end{exercise}

\begin{exercise}[title={Fonction de divisibilité}, level=basic]
L'exercice consiste à écrire une fonction nommée \texttt{divisible} qui retourne une valeur booléenne, laquelle indique si un des deux arguments est divisible par l'autre.
On peut supposer les entrées a et b entiers et non nuls, mais pas forcément positifs.
\vspace{-.25\baselineskip}
\end{exercise}

\begin{exercise}[title={Fonction définie par morceaux}, level=basic]
Obtenir en \textsc{Python} une fonction définie par morceaux telle que :
\begin{equation*}
  f \longrightarrow \left\{
  \begin{array}{ll}
  -x - 5 & \mbox{~si~} x \leq -5 \\
  0 & \mbox{~si~} x \in [-5,5] \\
  \dfrac{1}{5}x -1 & \mbox{~si~} x \geq 5
  \end{array}
  \right.
\end{equation*}
\vspace{-\baselineskip}
\end{exercise}

\begin{exercise}[title={Comptage au sein des chaînes}, level=basic]
Sur les systèmes de type \textsc{Unix}, la commande \texttt{wc} permet de compter le nombre de lignes, de mots et d'octets (ou de caractères) présents sur l'entrée standard ou contenus dans un fichier.

L'exercice consiste à écrire une fonction nommée \texttt{wc} qui prend en argument une chaîne de caractères et retourne une liste de trois éléments :
\begin{jazzitemize}
\item le nombre de lignes (plus précisément le nombre de retours à la ligne) ;
\item le nombre de mots (un mot étant séparé par des espaces) ;
\item le nombre de caractères (uniquement le jeu de caractères ASCII).
\end{jazzitemize}

\noindent Indice : la boucle \texttt{for} a été rapidement exposée, il faut toutefois savoir qu'on peut tout à fait résoudre l'exercice en utilisant uniquement la bibliothèque standard.

\noindent Remarque : usuellement, ce genre de fonctions retourne plutôt un tuple qu'une liste, mais ceux-ci n'ont pas encore été présentés.
\end{exercise}

\begin{solution}
Trois solutions sont possibles.
\begin{idleconsole}
\begin{pyconsole}
def label(prenom, note):
    if note < 10:
        return f"{prenom} est recalé"
    elif note < 16:
        return f"{prenom} est reçu"
    else:
        return f"Félicitations à {prenom}"

label('Rémi', 10)
label('Marie', 17)
label('Kevin', 8)
label('Jean', 14)
# Juste pour illustrer cette construction
def label_bis(prenom, note):
    if note < 10:
        return f"{prenom} est recalé"
    elif 10 <= note < 16:
        return f"{prenom} est reçu"
    else:
        return f"félicitations à {prenom}"

# L'expression conditionnelle n'a pas été abordée
# mais par curiosité on peut aussi faire comme ceci
def label_ter(prenom, note):
    return f"{prenom} est recalé" if note < 10 \
    else f"{prenom} est reçu" if 10 <= note < 16 \
    else f"félicitations à {prenom}"

\end{pyconsole}
\end{idleconsole}
\end{solution}

%label_bis('Rémi', 10)
%label_bis('Marie', 17)
%label_bis('Kevin', 8)
%label_bis('Jean', 14)

%label_ter('Rémi', 10)
%label_ter('Marie', 17)
%label_ter('Kevin', 8)
%label_ter('Jean', 14)

%\vspace{-0.5\baselineskip}
\begin{solution}
\begin{idleconsole}
\begin{pyconsole}
chaine[-5:-2] == "vwx"
chaine[-4:len(chaine)] == "wxyz"
chaine[3:len(chaine):2] == "dfhjlnprtvxz"
chaine[-3::-3] == "xurolifc"
\end{pyconsole}
\end{idleconsole}
\end{solution}

\begin{solution}
Pour enlever à gauche et à droite une chaîne de longueur \texttt{x}, on peut faire \texttt{composite[ x : -x ]}
or ici \texttt{x} vaut \texttt{len(connue)}

\begin{listingbox}{python}
def inconnue(composite, connue):
    return composite[ len(connue) : -len(connue) ]
\end{listingbox}

Ce qui peut aussi s'écrire comme ci-dessous si on préfère.
\begin{listingbox}{python}
def inconnue_bis(composite, connue):
    return composite[ len(connue) : len(composite)-len(connue) ]
\end{listingbox}
\end{solution}

\begin{solution}
\begin{idleconsole}
\begin{pyconsole}
def laccess(liste):
    """
    Retourne un élément de la liste selon la taille
    """
    if not liste: # Si la liste est vide ne rien faire
        return
    if len(liste) % 2 == 0: # Liste de taille paire
        return liste[-1]
    else:                   # Liste de taille impaire
        return liste[len(liste)//2]

laccess([])
laccess([1])
laccess(['spam', 100])
laccess(['spam', 100, 'bacon'])
laccess([1, 2, 3, 100])
laccess([1, 2, 100, 4, 5])
laccess(['si', 'pair', 'alors', 'dernier'])
laccess(['retourne', 'le', 'milieu', 'si', 'impair'])

# une autre version qui utilise un trait pas encore vu
def laccess_bis(liste):
    # si la liste est vide il n'y a rien à faire
    if not liste:
        return
    # l'index à utiliser selon la taille
    index = -1 if len(liste) % 2 == 0 else len(liste) // 2
    return liste[index]

\end{pyconsole}
\end{idleconsole}

%laccess_bis([])
%laccess_bis([1])
%laccess_bis(['spam', 100])
%laccess_bis(['spam', 100, 'bacon'])
%laccess_bis([1, 2, 3, 100])
%laccess_bis([1, 2, 100, 4, 5])
%laccess_bis(['si', 'pair', 'alors', 'dernier'])
%laccess_bis(['retourne', 'le', 'milieu', 'si', 'impair'])

Une fois que le code fonctionne, on peut regarder si par hasard il fonctionnerait aussi avec des chaînes de caractères.

\begin{idleconsole}
\begin{pyconsole}
laccess("")
laccess("a")
laccess("ab")
laccess("abc")
laccess("abcd")
laccess("abcde")
\end{pyconsole}
\end{idleconsole}
\end{solution}

\begin{solution}
Là encore, il y a deux formalisations possibles.

\begin{idleconsole}
\begin{pyconsole}
def divisible(a, b):
    "Renvoie True si un des deux arguments divise l'autre"
    # b divise a si et seulement si le reste
    # de la division de a par b est nul
    if a % b == 0:
        return True
    # et il faut regarder aussi si a divise b
    if b % a == 0:
        return True
    return False

def divisible_bis(a, b):
    "Renvoie True si un des deux arguments divise l'autre"
    # On n'a pas encore vu les opérateurs logiques, mais
    # on peut aussi faire tout simplement comme ça
    # sans faire de if du tout
    return a % b == 0 or b % a == 0

divisible(10, 30)
divisible(10, -30)
divisible(-10, 30)
divisible(8, 12)
divisible(12, -8)
divisible(-12, 8)
divisible(-12, -8)
divisible(10, 1)
divisible(30, -10)
divisible(-30, 10)
divisible(-30, -10)
\end{pyconsole}
\end{idleconsole}
\end{solution}

%divisible(-10, -30)
%divisible(30, 10)

%divisible_bis(10, 30)
%divisible_bis(10, -30)
%divisible_bis(-10, 30)
%divisible_bis(-10, -30)
%divisible_bis(8, 12)
%divisible_bis(12, -8)
%divisible_bis(-12, 8)
%divisible_bis(-12, -8)
%divisible_bis(10, 1)
%divisible_bis(30, 10)
%divisible_bis(30, -10)
%divisible_bis(-30, 10)
%divisible_bis(-30, -10)


\begin{solution}
Ici, trois formulations sont possibles.
\begin{idleconsole}
\begin{pyconsole}
def morceaux(x):
    if x <= -5:
        return -x - 5
    elif x <= 5:
        return 0
    else:
        return x / 5 - 1

def morceaux_bis(x):
    if x <= -5:
        return -x - 5
    if x <= 5:
        return 0
    return x / 5 - 1

def morceaux_ter(x):
    if x <= -5:
        return -x - 5
    elif -5 <= x <= 5:
        return 0
    else:
        return x / 5 - 1

morceaux(-10)
morceaux(0)
morceaux(10)
morceaux(-6)
morceaux(-4)
morceaux(5)
morceaux(-5)
morceaux(4)
morceaux(20)
\end{pyconsole}
\end{idleconsole}

En référence à la fonction \texttt{morceaux}, on veut visualiser le résultat. Autrement dit, en partant du code de la fonction, on veut produire sa courbe en utilisant\caution[t]<firstcolor>{%
Par rapport à l'interactivité d'un \textit{notebook} \textsc{Jupyter}, nous sommes contraints d'enregistrer la figure, puis de l'insérer au document. En effet, l'affichage écran n'a lieu qu'au moment de la compilation \LaTeX\ avec l’extension \textsc{Python}\TeX{}. L'affichage interactif est ainsi introduit en commentaire.}{Note de la rédaction}
 \textsc{numpy} et \textsc{matplotlib}. 

\begin{idleconsole}
\begin{pyconsole}
# Importation des bibliothèques
import numpy as np
import matplotlib.pyplot as plt

# Échantillons : X entre -10 et 20 et Y correspondants
X = np.linspace(-10, 20) 
Y = np.vectorize(morceaux)(X)

# On n'a plus qu'à dessiner
plt.xlabel("Axe des abscisses")
plt.ylabel('Axe des ordonnées')
plt.title('Fonction par morceaux')
plt.plot(X, Y)

# Affichage à l'écran
#plt.show() 
# Pour affichage ultérieur
plt.savefig('morceaux.png', transparent=True, dpi=300)
plt.close()
\end{pyconsole}
\end{idleconsole}

%#plt.xlim(-10, 20)
%#plt.ylim(0, 5)

\begin{center}
\vspace{-.75\baselineskip}
\IfFileExists{./PythonTeX/morceaux.png}%
  {\includegraphics[width=\linewidth]{./PythonTeX/morceaux.png}}%
  {\textbf{!! Missing matplotlib graphics !!}}%
\end{center}
\vspace{-.75\baselineskip}
\end{solution}

\begin{solution}
\vspace{-.25\baselineskip}
\begin{idleconsole}
\begin{pyconsole}
def wc(string):
    """
    Compte les nombres de lignes, de mots et de caractères
    Retourne une liste de ces trois nombres 
    (à noter qu'usuellement on renverrait plutôt un tuple)
    """
    # On peut tout faire avec la bibliothèque standard
    nb_lines = string.count('\n')
    nb_words = len(string.split())
    nb_bytes = len(string)
    return [nb_lines, nb_words, nb_bytes]

wc('')
wc('abc')
wc('abc \t')
wc('a  bc \t')
wc(' \tabc \n')
wc(" ".join("abcdefg") + "\n")
wc('''The Zen of Python, by Tim Peters)
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
...'''),

\end{pyconsole}
\end{idleconsole}
\end{solution}


%----------
\section[\texorpdfstring{Introduction aux compréhensions\newline de listes et aux modules}{Introduction aux compréhensions de listes et aux modules}]{Compréhensions de listes et modules}
\label{sec:XI.4}


\subsection[Compréhensions de liste]{Compréhensions de liste}
\label{sub:XI.4.1}

\begin{marginvideo}
	[\label{vid:XI.8}Compréhension de liste.]%
	\movie[width=\marginparwidth,showcontrols]%
		{\includegraphics[width=\marginparwidth]{./Images/Pictograms/film-strip-dark-electric-blue.png}}%
		{./Videos/Chapter11/vidXI-07-comprehension-listes-HD.mp4}%
	\launchvideo{./Videos/Chapter11/vidXI-07-comprehension-listes-HD.mp4}
\end{marginvideo}

Les listes sont au cœur de tout programme \textsc{Python}. La liste est en effet un objet flexible pouvant référencer n'importe quel type d'objet. 

Une manière simple de parcourir les listes est d'implémenter une boucle \texttt{for} pour appliquer une opération à chaque élément. Cette opération est tellement commune que \textsc{Python} a inventé une nouvelle expression qu'on appelle \emph{compréhension de liste}. Cette dernière permet, de manière simple et intuitive, d'adresser une opération aux éléments d'une liste et éventuellement d'ajouter une condition de filtre.

\subsubsection[Syntaxe et utilisation]{Syntaxe et utilisation}
\label{subsub:XI.4.1.1}

Supposons que l'on souhaite prendre le logarithme d'une liste d'entiers \texttt{a = [1,4,18,29,13]}. Il faut importer le module math qui implémente le logarithme. Essayons ensuite de mettre le résultat dans une nouvelle liste contenant le logarithme des éléments de \texttt{a}. On crée une liste vide \texttt{b=[]} et on établit une boucle \texttt{for} sur les éléments de \texttt{a} et de \textbf{b} pour aller chercher le logarithme.

\begin{idleconsole*}
\begin{pyconsole}
a = [1, 4, 18, 29, 13]
import math
b = []
for i in a:
    b.append(math.log(i))

b
\end{pyconsole}
\end{idleconsole*}

Le concept de compréhension de liste permet une écriture plus ramassée et fournit directement une nouvelle liste, ici des logarithmes des éléments de \texttt{a}. Pour s'en convaincre, il suffit de comparer la syntaxe du résultat précédent avec la nouvelle formulation qui s'avère quasiment du langage naturel.

\begin{idleconsole*}
\begin{pyconsole}
b = [math.log(i) for i in a]
b
\end{pyconsole}
\end{idleconsole*}

Supposons désormais que dans la liste \texttt{a} il y ait un entier négatif : \texttt{a.append(-1)}. On ne peut donc plus calculer le logarithme de cet élément. Néanmoins, avec une compréhension de liste, on peut rajouter un test comme suit pour contourner le problème.

\begin{idleconsole*}
\begin{pyconsole}
a.append(-1)
a
b = [math.log(i) for i in a if i > 0]
b
\end{pyconsole}
\end{idleconsole*}

On pourrait croire avec ces exemples que les compréhensions de listes sont réservées aux calculs sur des nombres entiers. En fait, cela n'est absolument pas le cas. Une compréhension de listes permet d'appliquer n'importe quelle opération, instruction et fonction sur n'importe quelle type de séquence.

Prenons maintenant un exemple avec des chaînes de caractères en partant d'une liste de prénoms dont certains dont une mauvaise capitalisation : \texttt{prenom = ['Alice','evE','sonia','BOB']} et essayons de tous les mettre en lettres minuscules avec la méthode \texttt{lower()} des chaînes de caractères. On peut tout aussi bien mettre en capitale uniquement la première lettre des prénoms avec la méthode \texttt{title()}.

\begin{idleconsole}
\begin{pyconsole}
prenom = ['Alice', 'evE', 'sonia', 'BOB']
prenom
prenom = [p.lower() for p in prenom]
prenom
prenom = [p.title() for p in prenom]
prenom
\end{pyconsole}
\end{idleconsole}

\subsubsection[Exercices]{Exercices}
\label{subsub:XI.4.1.2}

\begin{exercise}[title={Fonction polynomiale}, level=basic]
On se donne une fonction polynomiale :
%\vspace{-.75\baselineskip}
%\begin{equation*}
$P(x) = 2x^2 - 3x - 2$.
%\end{equation*}
%\vspace{-\baselineskip}

Il est demandé d'écrire une fonction \texttt{liste\_P} qui prend en argument une liste de nombres réels \texttt{x} et qui retourne la liste des valeurs P(x).

On suggère d'écrire une fonction \texttt{P} qui implémente le polynôme mais ça n'est pas strictement indispensable, seul le résultat de \texttt{liste\_P} compte.
\end{exercise}

\begin{exercise}[title={Mise au carré}, level=intermediate]
On demande à présent d'écrire une fonction dans le même esprit que la fonction polynomiale précédente. Cette fois, chaque ligne contient, séparés par des points-virgules, une liste d'entiers et on veut obtenir une nouvelle chaîne avec les carrés de ces entiers, séparés par des deux-points.

À nouveau les lignes peuvent être remplies de manière approximative, avec des espaces, des tabulations ou même des points-virgules en trop, que ce soit au début, à la fin ou au milieu d'une ligne.
\end{exercise}


\begin{solution}
\begin{idleconsole}
\begin{pyconsole}
def P(x):
    return 2 * x**2 - 3 * x - 2

def liste_P(liste_x):
    """
    retourne la liste des valeurs de P 
    sur les entrées figurant dans liste_x
    """
    return [P(x) for x in liste_x]

def liste_P_bis(liste_x):
    liste_y = []
    for x in liste_x:
        liste_y.append(P(x))
    return liste_y

a = list(range(5))
liste_P(a)
b = list(range(-7, 8, 2))
liste_P(b)
c = [-100, 0, 100]
liste_P(c)
\end{pyconsole}
\end{idleconsole}

On peut ensuite visualiser le résultat

\begin{idleconsole}
\begin{pyconsole}
# Importation des bibliothèques
import numpy as np 
import matplotlib.pyplot as plt

# Échantillons : X entre -10 et 10 et Y correspondants
X = np.linspace(-10, 10)
Y = liste_P(X)

# On n'a plus qu'à dessiner
plt.xlabel("Axe des abscisses")
plt.ylabel('Axe des ordonnées')
plt.title('Fonction polynomiale')
plt.plot(X, Y)

# Affichage à l'écran
#plt.show() 
# Pour affichage ultérieur
plt.savefig('polynome.png', transparent=True, dpi=300)
plt.close()
\end{pyconsole}
\end{idleconsole}

%#plt.xlim(-10, 10)
%#plt.ylim(0, 220)

\begin{center}
\vspace{-.75\baselineskip}
\IfFileExists{./PythonTeX/polynome.png}%
  {\includegraphics[width=\linewidth]{./PythonTeX/polynome.png}}%
  {\textbf{!! Missing matplotlib graphics !!}}%
\end{center}
\vspace{-.75\baselineskip}
\end{solution}


\begin{solution}
\begin{idleconsole}
\begin{pyconsole}
def carre(line):
    # On enlève les espaces et les tabulations
    line = line.replace(' ', '').replace('\t','')
    # La ligne suivante fait le plus gros du travail
    # d'abord on appelle split() pour découper selon les ';'
    # dans le cas où on a des ';' en trop, on obtient dans 
    # le résultat du split un 'token' vide, que l'on ignore 
    # ici avec la clause 'if token' enfin on convertit
    # tous les tokens restants en entiers avec int()
    entiers = [int(token) for token in line.split(";")
               # en éliminant les entrées vides qui
               # correspondent à des point-virgules en trop
               if token]
    # Il n'y a plus qu'à mettre au carré, retraduire
    # en strings et à recoudre le tout avec join et ':'
    return ":".join([str(entier**2) for entier in entiers])

def carre_bis(line):
    # Pareil mais avec, à la place des compréhensions
    # des expressions génératrices pas encore étudiées
    # L'illustration ici est d'avoir exactement
    # le même code mais avec () au lieu de []
    line = line.replace(' ', '').replace('\t','')
    entiers = (int(token) for token in line.split(";")
               if token)
    return ":".join(str(entier**2) for entier in entiers)

carre("1;2;3")
carre(" 2 ;  5;6;")
carre("; 12 ;  -23;\t60; 1\t")
carre("; -12 ; ; -23; 1 ;;\t")
\end{pyconsole}
\end{idleconsole}
\end{solution}


\subsection[Modules]{Modules}
\label{sub:XI.4.2}

\begin{marginvideo}
	[\label{vid:XI.9}Modules.]%
	\movie[width=\marginparwidth,showcontrols]%
		{\includegraphics[width=\marginparwidth]{./Images/Pictograms/film-strip-dark-electric-blue.png}}%
		{./Videos/Chapter11/vidXI-08-modules-HD.mp4}%
	\launchvideo{./Videos/Chapter11/vidXI-08-modules-HD.mp4}
\end{marginvideo}

Un module est un fichier \textsc{Python} standard se terminant par l'extension « \texttt{.py} ». Lorsque l'on importe ce fichier avec l'instruction \texttt{import}, cela crée un objet module.

Un module contient un certain nombre de fonctions et d'opérations prédéfinies. L'idée d'un module est de regrouper dans le même fichier des opérations similaires. Ce faisant, un module peut se voir comme une boîte à outils à laquelle on fait appel quand on a besoin de l'ouvrir.

\subsubsection[Attributs]{Attributs}
\label{subsub:XI.4.2.1}

On peut illustrer concrètement les choses à l'aide du module \textsc{random}. On peut vérifier sa nature par la fonction \texttt{print(random)}, qui renvoie que c'est bien un objet module.

On a accès à tous les attributs possibles du module avec la commande \texttt{dir(random)}. Pour mémoire, les attributs avec double \textit{underscore} ne sont pas à manipuler directement.

On peut également avoir de l'aide sur un module en utilisant la fonction \textit{buit-in} \texttt{help(random)}. Mentionnons au passage qu'il est rare d'utiliser l'aide directement car cela fait beaucoup de texte à traiter. Dans ce cas et en pratique, il est conseillé de consulter la documentation sur Internet. 

L'aide se trouve néanmoins utile lorsqu'on veut regarder le fonctionnement d'une méthode singulière d'un module, comme \texttt{random.randint?} avec \textsc{IPython} et \texttt{help(random.randint)} --- retour aléatoire d'un entier entre deux bornes inclues --- pour les autres interpréteurs.

%\vfill\pagebreak

\begin{idleconsole*}
\begin{pyconsole}[][breaklines]
import random
print(random)
dir(random)
help(random.randint)
random.randint(1, 100)
\end{pyconsole}
\end{idleconsole*}

\subsubsection[Bibliothèque standard et autres]{Bibliothèque standard et autres}
\label{subsub:XI.4.2.2}

\textsc{Python} est livré avec un grand nombre de modules --- environ une centaine. C'est ce qu'on appelle la \emph{bibliothèque standard}. Cela permet de réaliser de multiples opérations courantes. 

L'intérêt de la bibliothèque standard est d'avoir la certitude de disposer des mêmes modules pour chacune des installations de \textsc{Python}. 

Mentionnons quelques opérations possibles et réalisables au moyen de la bibliothèque standard :
\begin{itemize}\jazzitem
\item programmation parallèle ;
\item programmation asynchrone ;
\item persistance de données (sérialisation) ;
\item communication sur Internet (support de tous les protocoles) ;
\item formatage et lecture des données ;
\item manipulation de fractions et de nombres décimaux ;
\item écriture d'expressions régulières ;
\item gestion de dates et calendriers ;
\item interaction avec le système de fichiers ;
\item création de fichiers et répertoires ;
\item compression de fichiers ;
\item codage d'interfaces graphiques.
\end{itemize}

Outre la bibliothèque standard, \textsc{Python} peut intégrer des centaines de milliers de modules écrits par des groupes de développement ou des individus pour répondre à des usages spécifiques. Il suffit de les installer et de les charger pour en bénéficier, par exemple \textsc{Numpy} et \textsc{Pandas} en \textit{data-science} ou \textsc{Matplotlib} en visualisation de données.




\vfill\pagebreak





%----------
\section[Que faire de ces ressources ? Quiz]{Que faire de ces ressources ? Autoévaluation}
\label{sec:XI.5}

Le questionnaire\caution[t]<firstcolor>{%
La présentation des quiz du document\linebreak suit plus ou moins celle de la platefor\-me \textsc{Fun-Mooc}. La fonctionnalité manquante --- pas encore implémentée dans l'extension de style \LaTeX{} usitée --- est relative à la comptabilisation des points et à leur enregistrement. Aussi, il appartient au lecteur de jouer le jeu dans l'auto\-évaluation de ses connaissances.}{Note de la rédaction}
à choix multiple%
\parnote{De manière traditionnelle en \textsc{Ihm}, lorsqu'une seule réponse est correcte, les propositions sont précédées d'un cercle à cocher (\emph{radio button}) ; en revanche, dans le cas de plusieurs solutions possibles, il s'agit de carrés (\emph{check box}). En outre, après validation des réponses (« Vérifier »), leur explication s'affiche en marge ou infobulle (« Afficher la réponse »).}
--- QCM --- à suivre porte sur le présent chapitre \qnameref{chap:XI}.
\parnotes

\vspace{6pt}

\begin{quiz}[title={Codage et Unicode}]
\begin{quizquestion}[b]{3}{1,2}{Encodage}
<Le décodage sert à définir un découpage des bits en bloc pour obtenir un code que l'on utilisera pour trouver un caractère dans un jeux de caractères.> 
À quoi sert le décodage d'un flux de bits en informatique ?
\points{1}
	\mcqproposal{À obtenir un caractère.}
	\mcqproposal{À obtenir une phrase.}
	\mcqproposal{À obtenir un code que l'on utilisera pour trouver un caractère dans un jeu de caractères.}
\end{quizquestion}

\begin{quizquestion}[b]{1,2,3}{4}{Unicode}
<Unicode supporte tous les caractères du monde, il en contient actuellement plus de 120 000 caractères.> 
Cocher la ou les affirmations qui sont vraies.
\points{1}
	\mcqproposal{Unicode est un standard qui définit à la fois un jeu de caractères et des encodages.}
	\mcqproposal{Unicode définit trois encodages UTF-8, UTF-16 et UTF-32.}
	\mcqproposal{UTF-8 est l'encodage à favoriser.}
	\mcqproposal{Unicode ne supporte pas certains caractères courants comme le symbole de l'euro.}
\end{quizquestion}
\end{quiz}

\begin{quiz}[title={Chaînes de caractères}]
\begin{quizquestion*}[b]{2}{1}{Mutabilité}
<Faux, les chaînes de caractères sont immuables, ça veut dire qu'une fois l'objet créé on ne peut plus le modifier.> 
Les chaînes de caractères en \textsc{Python} sont mutables.
\points{1}
	\mcqproposal{Vrai.}
	\mcqproposal{Faux.}
\end{quizquestion*}

\begin{quizquestion}[b]{2,3,4,5,6}{1,7}{Expressions}
<Une chaîne de caractères est entourée soit par deux apostrophes \texttt{'} ou par deux guillemets anglais \texttt{"}. Si la chaîne est entourée par deux \texttt{'} (respectivement \texttt{"}), alors le caractère \texttt{"} (respectivement \texttt{'}) pourra être utilisé comme un caractère normal dans la chaîne de caractères.> 
Cocher la ou les expressions qui définissent correctement une chaîne de caractères en \textsc{Python}.
\points{1}
	\mcqproposal{\texttt{'spam"}}
	\mcqproposal{\texttt{"spam"}}
	\mcqproposal{\texttt{'spam"'}}
	\mcqproposal{\texttt{'spam'}}
	\mcqproposal{\texttt{'""'}}
	\mcqproposal{\texttt{"'"}}
	\mcqproposal{\texttt{'"'"}}
\end{quizquestion}

\begin{quizquestion}[b]{3,4}{1,2}{Formatage}
<Attention de ne pas mettre d'apostro\-phes (sans caractère « \texttt{\textbackslash} » devant) dans une chaîne de caractères délimitée par des apostrophes. Une \textit{f-string} doit toujours être précédée d'un « \texttt{f} ».> 
On veut afficher la chaîne de caractères \texttt{le numéro d'appel des urgences est le 112} et on a les variables suivantes qui sont définies : \texttt{text = 'des urgences'}, \texttt{numero = 112}. Quelle(s) solution(s) est(sont) correcte(s) ?
\points{1}
	\mcqproposal{\texttt{'le numéro d'appel \{\} est le \{\}'.format(text, numero)}.}
	\mcqproposal{\texttt{"le numéro d'appel {text} est le {numero}"}.}
	\mcqproposal{\texttt{"le numéro d'appel {} est le {}".format(text, numero)}.}
	\mcqproposal{\texttt{f"le numéro d'appel {text} est le {numero}"}.}
\end{quizquestion}

\begin{quizquestion}[b]{1,2}{3}{Encodage}
<On peut décoder et encoder une chaîne de caractères autant de fois que nécessaire.> 
Quelle(s) affirmation(s) est(sont) vraie(s) ?
\points{1}
	\mcqproposal{Sans spécifier explicitement l'encodage choisi, le codage utilisé sera dépendant de la machine sur laquelle on fait tourner le programme.}
	\mcqproposal{Le type \texttt{str} est pour les chaînes de caractères décodées et le type \texttt{bytes} est pour les chaînes de caractères encodées.}
	\mcqproposal{Lorsqu'une chaîne est décodée on ne peut plus l'encoder.}
\end{quizquestion}
\end{quiz}

\begin{quiz}[title={Séquences}]
\small

\begin{quizquestion}[b]{2}{1}{Longueur}
<En effet, \texttt{chaine.index(x)} renvoie un index valide dans \texttt{chaine}, ça ne peut donc pas être la longueur de \texttt{chaine}; le dernier index valide dans une chaine non vide est toujours un de moins que la longueur de la chaîne.> 
On se donne la variable suivante : \texttt{chaine="douarnenez"}. Parmi les expressions suivantes, quelles sont celles qui s'évaluent à \texttt{True} ?
\points{1}
	\mcqproposal{\texttt{chaine.index('z') == len(chaine)}.}
	\mcqproposal{\texttt{chaine.index('z') == len(chaine) - 1}.}
\end{quizquestion}

\begin{quizquestion}[b]{2}{1}{Appartenance}
<On retrouve bien la sous-chaîne 'nez' dans la chaîne de départ.
S'agissant de la première sous-chaîne, bien que naturellement toutes les lettres prises individuellement sont présentes, on ne trouve pas la sous-chaîne telle quelle.> 
On se donne la variable suivante : \texttt{chaine="douarnenez"}. Parmi les expressions suivantes, quelles sont celles qui s'évaluent à \texttt{True} ?
\points{1}
	\mcqproposal{\texttt{'daz' in chaine}.}
	\mcqproposal{\texttt{'nez' in chaine}.}
\end{quizquestion}

\begin{quizquestion}[b]{1,2}{}{{\itshape Slicing}}
<Dans le premier cas \texttt{chaine[-3:]} prend les trois derniers caractères de la chaî\-ne, c'est bien correct.
Dans le second\linebreak cas, on peut alors remarquer que la notation des \textit{slices} fonctionne de telle sorte que \texttt{chaine[a:b] + chaine[b:c]} donne toujours \texttt{chaine[a:c]} lorsque \texttt{a}, \texttt{b} et \texttt{c} sont en ordre croissant.> 
On se donne la variable suivante : \texttt{chaine="douarnenez"}. Parmi les expressions suivantes, quelles sont celles qui s'évaluent à \texttt{True} ?
\points{1}
	\mcqproposal{\texttt{chaine[-3:] == 'nez'}.}
	\mcqproposal{\texttt{chaine[1:3] + chaine[3:5] + chaine[5:] == chaine[1:]}.}
\end{quizquestion}
\end{quiz}

\begin{quiz}[title={Listes}]
\begin{quizquestion}[b]{3,5}{1,2,4}{Insertion}
<La première formule remplace \texttt{2} par \texttt{4}, liste conserve quatre éléments et devient \texttt{[0, 1, 4, 3]}.
La seconde, idem mais liste devient \texttt{[0, 1, [4], 3]}.
La troisième est correcte.
La quatrième est équivalente à la première, elle remplace \texttt{2} par \texttt{4}.
La cinquième est correcte également.> 
On a \texttt{liste = [0, 1, 2, 3]}. On veut modifier l'objet \texttt{liste} pour que sa valeur devienne \texttt{[0, 1, 4, 2, 3]}
Que faut-il faire ? Plusieurs réponses sont possibles.
\points{1}
	\mcqproposal{\texttt{liste[2] = 4}}
	\mcqproposal{\texttt{liste[2] = [4]}}
	\mcqproposal{\texttt{liste.insert(2,4)}}
	\mcqproposal{\texttt{liste[2:3] = [4]}}
	\mcqproposal{\texttt{liste[2:2] = [4]}}
\end{quizquestion}

\begin{quizquestion}[b]{2,4}{1,3,5}{Extraction}
<La première formule retourne bien \texttt{0} mais ne modifie pas liste. La seconde est correcte. La troisième enlève bien \texttt{0} de liste mais ne retourne rien. La quatrième version fonctionne --- quoi qu'assez peu « pythonique ». La dernière formule est syntaxiquement incorrecte; \texttt{del} est une instruction et ne peut pas être utilisée comme résultat d'une affectation.> 
On a de nouveau \texttt{liste = [0, 1, 2, 3]}. On souhaite extraire et retourner le premier élément \texttt{0}, tout en la retirant de la liste. Plus précisément on veut affecter à la variable suivant la valeur \texttt{0} de telle sorte qu'après l'exécution, liste ne contienne plus que \texttt{[1, 2, 3]}.
Que faut-il faire ? Plusieurs réponses sont possibles.
\points{1}
	\mcqproposal{\texttt{suivant = liste[0]}}
	\mcqproposal{\texttt{suivant = liste.pop(0)}}
	\mcqproposal{\texttt{del liste[0]}}
	\mcqproposal{\texttt{suivant = liste[0]; del liste[0]}}
	\mcqproposal{\texttt{suivant = del liste[0]}}
\end{quizquestion}

\begin{quizquestion}[b]{1,4}{2,3}{Tri}
<Il faut bien préciser \texttt{reverse=True} pour obtenir un tri décroissant. On ne veut pas dupliquer la liste initiale, ce n'est donc pas une bonne idée d'utiliser \texttt{sorted}. La dernière formule s'avère très bien fonctionner également.> 
On a cette fois \texttt{liste = [1, 0, 3, 2]}. On veut trier la liste en ordre décroissant et \emph{en place}, c'est-à-dire \emph{sans dupliquer} la liste ni ses éléments. Que faut-il faire ? Plusieurs réponses sont possibles.
\points{1}
	\mcqproposal{\texttt{liste.sort(reverse=True)}}
	\mcqproposal{\texttt{liste.sort()}}
	\mcqproposal{\texttt{sorted(liste, reverse=True)}}
	\mcqproposal{\texttt{liste.sort(); liste.reverse()}}
\end{quizquestion}
\end{quiz}

\begin{quiz}[title={Conditionnelles et syntaxe}]
\begin{quizquestion*}[b]{1}{2,3}{Test}
<Il manque le « {\ttfamily :} » en fin de ligne du {\ttfamily if} pour que la syntaxe soit correcte.> 
Que peut-on dire du code suivant ?
\begin{listingbox}{python}
if 1 < 2
    print('oui')
else:
    print('non')
\end{listingbox}
\points{1}
	\mcqproposal{Ce code est invalide.}
	\mcqproposal{Ce code affiche « \texttt{oui} ».}
	\mcqproposal{Ce code affiche « \texttt{non} ».}
\end{quizquestion*}

\begin{quizquestion}[b]{1,4}{2,3}{Convention de codage}
<\textsc{Python} impose des contraintes fortes sur la manière de présenter le code en faisant entrer la présentation du code dans la syntaxe du langage. Un bloc d'instruction est nécessairement identifié par une indentation commune de chaque ligne, mais pas par des accolades.>
Quelle(s) affirmation(s) est(sont) vraie(s) ?
\points{1}
	\mcqproposal{Des conventions de codage sont dans la syntaxe de \textsc{Python}.}
	\mcqproposal{Il y a peu de contraintes sur la manière de présenter le code.}
	\mcqproposal{On utilise des accolades pour identifier les blocs d'instructions}
	\mcqproposal{Il faut toujours un « \texttt{:} » en fin de ligne précédant un bloc de code.}
\end{quizquestion}
\end{quiz}

\begin{quiz}[title={Boucle et fonctions}]
\begin{quizquestion}[b]{3}{1,2,4}{Boucle}
<La boucle parcourt la liste, convertit chaque élément en chaîne de caractères et met le résultat dans une nouvelle liste. On affiche ensuite le résultat du \texttt{",".join(a)} qui produit une chaîne de caractères qui contient chaque élément de la nouvelle liste séparé par une virgule.> 
Voici une boucle \texttt{for}, que va afficher cette boucle.
\begin{listingbox}{python}
a = []
for n in [1, 2, '3', 4, 'FIN']:
    a.append(str(n))
print(",".join(a))
\end{listingbox}
\vspace{6pt}
\points{1}
	\mcqproposal{Une erreur.}
	\mcqproposal{\texttt{1,2,'3',4,'FIN'}.}
	\mcqproposal{\texttt{1,2,3,4,FIN}.}
	\mcqproposal{\texttt{1},\\ \texttt{2},\\ \texttt{3},\\ \texttt{4},\\ \texttt{FIN}}
\end{quizquestion}

\begin{quizquestion}[b]{1,2,3}{4,5,6}{Fonctions}
<Les trois premiers appels retournent le bon résultat, puisque la boucle for de la fonction parcourt une séquence.
Le quatrième appel n'a pas de sens puisque la fonction \texttt{to\_str} n'est pas définie sur les listes.
Le cinquième appel est faux puisque \texttt{to\_str} n'appelle pas la fonction, pour l'appeler il faut utiliser des parenthèses et lui passer un argument dans notre cas. Le sixième appel parcourt la liste qui ne contient qu'un élément la chaîne \texttt{'123'}. > 
Voici une fonction.
\begin{listingbox}{python}
def to_str(a):
    tmp = []
    for i in a:
        tmp.append(str(i))
    return " ".join(tmp)
\end{listingbox}
\vspace{6pt}
Quel(s) appel(s) va(vont) produire le retour suivant : \texttt{'1 2 3'}.
\points{1}
	\mcqproposal{\texttt{to\_str([1, 2, 3])}}
	\mcqproposal{\texttt{to\_str(['1', '2', '3'])}}
	\mcqproposal{\texttt{to\_str('123')}.}
	\mcqproposal{\texttt{[1, 2, 3].to\_str()}}
	\mcqproposal{\texttt{a = [1, 2, 3]},\\ \texttt{to\_str}}
	\mcqproposal{\texttt{to\_str(['123'])}}
\end{quizquestion}
\end{quiz}

\begin{quiz}[title={Compréhension de liste}]
\begin{quizquestion}[b]{2,5}{1,3,4}{Listes de carrés}
<Les compréhensions ne contiennent jamais de « \texttt{:} » qui est réservé aux \emph{instructions} (les compréhensions sont toujours des \emph{expressions}).> 
On suppose avoir la liste : \texttt{entree = [1,2,3,4,5,6,7,8,9]}. Parmi les fragments suivants, lesquels sont valides en \textsc{Python} ? 
\points{1}
	\mcqproposal{\texttt{carres = [for x in entree: x**2]}}
	\mcqproposal{\texttt{carres = [x**2 for x in entree]}.}
	\mcqproposal{\texttt{carres = [for x in entree: if x \% 3 == 0: x**2]}.}
	\mcqproposal{\texttt{carres = [x**2 for x in entree: if x \% 3 == 0]}}
	\mcqproposal{\texttt{carres = [x**2 for x in entree if x \% 3 == 0]}}
\end{quizquestion}
\end{quiz}













